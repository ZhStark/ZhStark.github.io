<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[重学cpp4 数组]]></title>
    <url>%2F2019%2F03%2F25%2F%E9%87%8D%E5%AD%A6cpp-array%2F</url>
    <content type="text"><![CDATA[数组的声明，指针，二维数组 复杂的数组声明12345int *ptrs[10]; //ptrs 是一个含有10个 整型指针 的数组int &amp;refs[10]= arr; // Wrong，不存在引用的数组int (*P)[10]=&amp;arr; // P是一个指针，指向一个含有10个整数的数组int (&amp;arrRef)[10]=arr; //arrRef 引用一个含有10个整数的数组int * (&amp;arr)[10]=ptrs; //arr 是数组的引用，该数组含有10个指针 指针与数组123456string nums[]=&#123;"onr", "two", "three"&#125;;string *p=nums; // string *p=&amp;nums[0];auto p2(nums); //p2为指向字符串的指针，指向 nums 的第一个元素auto p2(&amp;nums[0]);*p2="sfa"; 当用decltype时，跟上面又不一样了，不再返回指针，而是返回数组 123int ia[]=&#123;1,2,3,4,5,6,7,8,9,0&#125;;decltype(ia) ia2=&#123;0,1,2,3,4,5,6,7,8,9&#125;; //decltype 返回的类型是由10个整数构成的数组 把指针当迭代器重点在于找到终止点。 12345int *e=&amp;arr[10]; //指向 arr 最后一个元素的下一个位置。for(int *b=arr; b!=e; ++b)&#123;&#125;// orint *e=end(arr); //#include &lt;iterator&gt;int *b=begin(arr); //This is better 二维数组初始化 1234567int a[3][4]=&#123; &#123;0,1,2,3&#125;, &#123;4,5,6,7&#125;, &#123;8,9,0,1&#125;&#125;;int a[3][4]=&#123;0,1,2,3,4,5,6,7,8,9,0,1&#125;; //same]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学c++3 decltype & string]]></title>
    <url>%2F2019%2F03%2F24%2F%E9%87%8D%E5%AD%A6cpp-decltype-and-string%2F</url>
    <content type="text"><![CDATA[decltype 返回方程的返回类型 三 decltypedecltype的作用是选择并返回操作数的数据类型12345decltype(f()) s=x; //s 的类型为函数 f 的返回值类型const int c1=0, &amp;c2=c1;decltype(c1) x=0; //const int xdecltype(c2) y=x; //const int &amp;y=x; 如果 decltype 的表达式加上了一对括号，这样的 decltype 会得到一个引用类型 12int i=0;decltype((i)) d=i; // d是一个 int&amp; 引用变量 四using 声明123using namespace::name;using std::cin; 头文件的代码一般不能使用 using 声明，因为头文件的内容会拷贝到所有引用他的文件中去。 Stringgetline 函数在最终得到的字符串中保留输入时的空白符getline(ins, s) 第一个参数是输入流，第二个参数是 string。函数从输入流中读入内容，直到遇到换行符为止。 输入运算符作为判断条件1while(cin&gt;&gt;value) cin&gt;&gt;value 返回 cin，一个istream 对象。当使用istream对象作为判断条件时，效果是检测流的状态。当遇到文件结束符或一个无效的输入时，判断为假。123456int main()&#123;string line; while(getline(cin, line)) cout&lt;&lt;line&lt;&lt;endl; return 0;&#125; string 相加当把 string 对象和字符字面值及字符串字面值混在一条语句中使用，必须确保每个加法运算符的两侧的运算对象至少有一个是 string1234string s4=s1+","; //rightstring s5= "hello"+","; //wrongstring s6=s1+","+"hjello"; //rightstring s7="hello"+","+s1; //wrong 处理字符123456789#include &lt;cctype&gt;isalnum(c)isalpha(c)isdigit(c)islower(c)isupper(c)isspace(c)tolower(c)toupper(c)]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学C++2 const]]></title>
    <url>%2F2019%2F03%2F16%2F%E9%87%8D%E5%AD%A6cpp-const%2F</url>
    <content type="text"><![CDATA[指向常量的指针，常量指针，指向常量的常量指针 = =！ const默认状态下，const对象只在文件内有效。如果只在一个文件中定义 const，而在其他多个文件中声明并使用它，那么对 const 变量不管是声明还是定义都添加extern 关键字。1234//file.cc中定义并初始化extern const int a=1;//file.h 中声明extern const int a; //这俩 a 是同一个 对常量的引用（reference to const） 123const int c1=1;const int &amp;r1=c1;int &amp;r2=c1; //错误，非常量引用不能指向常量 指向常量的指针 要想放常量的地址，只能用指向常量的指针。123const double pi=3.14;double *p1=&amp;pi; // WRONG!const double *p2= &amp;pi; //Right const 指针允许吧指针本身定义为常量，常量指针（const pointer）必须初始化。把*放在 const 之前，来说明指针是一个常量，此时不变的是指针本身，而不是指针指向的值。1234int num=0;int *const p=&amp;num; // const pointer，p 不能改，（*p)可以改const double pi=3.14;const double *const p2=&amp;pi; 弄清声明含义可以从右向左读。 顶层 const &amp; 底层 const顶层 const 可以表示任意的对象是常量（如表明指针本身是一个常量），而底层 const 表示指针所指的对象使一个常量。 常量表达式 const expression常量表达式是指值不变并且在编译过程就能得到计算结果的表达式。 C++11允许将变量声明为 constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为 constexpr 的变量一定是一个常量，而且必须用常量表达式初始化。（还有 constepr 函数，在编译时计算出结果）。 在 constexpr 声明中如果定义了一个指针，限定符 constexpr 仅对指针有效，与指针所指的对象无关。 12345const int *p=nullptr; //一个指向整型常量的指针constexpr int *q=nullptr; //一个指向整数的常量指针constexpr int i=0;constexpr const int *pp=&amp;i; //指向常量的常量指针 类型别名类型别名是一个名字，是某种类型的同义词。有两种方法。 1.typedef12typedef double wages; //wages 就是 doubletypedef wages base, *p; // base 就是 double，p 是 double *的同义词 2.别名声明1using SI=int; 坑：如果某个类型别名指代的是复合类型或常量，结果跟你想的可能不太一样。 123typedef char *pstring; //pstring 是 char * 别名const pstring cs=0； // cs 是指向 char 的 “常量指针”！不是指向常量字符的指针const pstring *p; //p是一个指针，他的对象是指向 char 的常量指针]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>tech, C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学 C++]]></title>
    <url>%2F2019%2F03%2F09%2F%E9%87%8D%E5%AD%A6%20cpp%2F</url>
    <content type="text"><![CDATA[之前学的不够扎实，更加系统、贴近底层的学一遍。非新手笔记，都是比较基础的东西，但没有最最基础的东西 零main 函数的返回类型必须是int，返回 0 表明成功。 curly brace 花括号 block of statements 语句块 assignment 赋值 windows: .\表示该文件在当前目录中，Unix: ./ 表示可执行文件在当前目录中。 stream：流，一个流就是一个字符序列。随着时间的推移，字符是顺序生成或消耗的。 cin cout cerr clog &lt;&lt; 输出运算符，返回其左侧的运算对象 endl是一个被称为操作符(manipulator)的特殊值，写入endl的效果是结束当前行，并将于设备关联的 buffer 中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流。 :: 作用域运算符 &gt;&gt; 输入运算符，返回左侧运算对象 当用一个istream 对象作为判断条件时，其效果是检测stream 的状态。当流未遇到错误，即为true。但遇到文件结束符（ctrl+D in Mac）或遇到无效输入，状态变为无效，条件为 false。 文件重定向 将标准输入和标准输出与命名文件关联起来。1$ addItems &lt;infile&gt;outfile addItem 为编译后的可执行文件，上述命令会从一个名为 infile 的文件读取销售记录，并将输出结果写入一个名为 outfile 的文件中。123456789#include&lt;iostream&gt;#include "Sale_item.h"int main()&#123; Sale_item item1, item2; std::cin&gt;&gt;item1&gt;&gt;item2; std::cout&lt;&lt;item1+item2&lt;&lt;std::endl; return 0;&#125; 一可寻址的最小内存块称为 字节 (byte)，存储的基本单元称为 字 (word)，一个字节由八个比特（bit）构成，一个字由32或64比特构成。 char 8位（bits），一字节（bytes） int 32位，四字节 float ，32位，6位有效数字 double 64位，10位有效数字 char16_t &amp; char32_t 为 Unicode 字符 short 16bits long 32 bits long long 64 bits long double 96 or 128 bits 0开头为八进制，0x 开头十六进制 执行浮点数运算选用 double， 因为 float 通常精度不够，而且双精度浮点数和单精度浮点数的计算代价差不多。 勿混用有符号类型与无符号类型如果 int 和无符号运算，那么 int 值会自动转变为无符号数。 当从无符号数中减去一个值时，不管这个数是不是无符号数，我们都必须确保结果不能是一个负值。 1234unsigned int u1=42,u2=10;cout&lt;&lt;u2-u1&lt;&lt;endl;输出：4294967264 浮点数科学计数法表示：指数部分用 E 或 e 标识: 24E2->2400 引用（reference）为对象起了另外一个名字，引用必须被初始化。通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。即定义了一个引用后，对其进行的所有操作都是在与之绑定的对象上进行的。 空指针不指向任何对象，在试图使用一个指针之前代码可以先检测它是否为空。123int *p1=nullptr; // &lt;--- bestint *p2=0;int *p3=NULL; //#include &lt;cstdlib&gt; 把 int 变量直接给指针是错误的，即使该值是0。 指向指针的引用 12345int i=42;int *p;int *&amp;r=p; // r 是一个对指针 p 的引用r=&amp;i; // p 指向 r*r=0; 从右向左阅读 r 的定义，首先是&amp;，说明 r 是一个引用，其次是*，表示 r 引用的是指针，最后int，r 引用的是 int 指针。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>tech, C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++函数的参数的不同传递方式]]></title>
    <url>%2F2019%2F02%2F28%2FC-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E7%9A%84%E4%B8%8D%E5%90%8C%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[面试要用 C++，没用 C++写过任何 project， 从头开始学 妈耶可烦死我了。 刷题时看到关于 C++函数的参数传递有好多形式，有直接传的，有传指针的，还有传&amp;，最后一个没怎么见过。找了些资料，发现这些对应的是值传递，指针传递和引用传递。 在这个博客找到了非常深入的解释，摘抄部分如下： （注：函数中用于接收传递值的变量叫形参，传递给函数的值叫实参） 值传递： 形参是实参的拷贝，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参-&gt;形参），参数的值只能传入，不能传出。当函数内部需要修改参数，并且不希望这个改变影响调用者时，采用值传递。1void f1(int n)&#123;n++;&#125; // 外面传来的 n 不变 指针传递： 形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作1void f2(int *n)&#123;*n=*n+1;&#125; //外面的 n 也变 引用传递： 形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。 12345void f3(int &amp;n)&#123;n++;&#125; ////外面的 n 也变//对引用传递，传入的时候只是传 n，不同于指针传 &amp;nint n=2;f3(n);]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github page自定义域名的 ip 过时]]></title>
    <url>%2F2019%2F02%2F16%2Fgithub%20page%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E7%9A%84%20ip%20%E8%BF%87%E6%97%B6%2F</url>
    <content type="text"><![CDATA[今天改博客的时候，每次部署都会收到 github 的邮件说： The custom domain for your GitHub Pages site is pointed at an outdated IP address. You must update your site’s DNS records if you’d like it to be available via your custom domain. 因为现在 github page 现在的ip换了，之前自己的域名绑定的ip 不再试用。 解决之道： 登录自己的域名管理网站（我的是托管到 DNSPOD 上的），将之前的 ip 为192.30.252.153的关掉，添加 185.199.108.153]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习笔记2]]></title>
    <url>%2F2019%2F02%2F16%2Fpython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%2F</url>
    <content type="text"><![CDATA[接上部 位操作符 Othereval( )eval() 函数用来执行一个字符串表达式，并返回表达式的值。 range( ) 倒序range(a,b,-1) enumerate( ) 函数enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中. 12345678910111213&gt;&gt;&gt;seasons = ['Spring', 'Summer', 'Fall', 'Winter']&gt;&gt;&gt; list(enumerate(seasons))[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]&gt;&gt;&gt; list(enumerate(seasons, start=1)) # 下标从 1 开始[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]&gt;&gt;&gt;seq = ['one', 'two', 'three']&gt;&gt;&gt; for i, element in enumerate(seq):... print i, element...0 one1 two2 three filter( ) 函数filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回一个迭代器对象，如果要转换为列表，可以使用 list() 来转换。 该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。 12345678910#!/usr/bin/python3def is_odd(n): return n % 2 == 1tmplist = filter(is_odd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])newlist = list(tmplist)print(newlist)&gt;&gt;&gt;[1, 3, 5, 7, 9] zip( ) 函数zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象，这样做的好处是节约了不少的内存。return min((b-a) for a, b in zip(m, m[1:])) divmod( )函数python divmod() 函数把除数和余数运算结果结合起来，返回一个包含商和余数的元组(a // b, a % b)。 join( ) 函数‘s’.join(str)s: 分隔符，可以为空str：要连接的元素序列、字符串、元组、字典上面的语法即：以sep作为分隔符，将seq所有的元素合并成一个新的字符串 返回值：返回一个以分隔符sep连接各个元素后生成的字符串 __contains__在类中定义，在外面当用到 for i in class 时，in 调用该函数in = contains()x.__contain__(y)&lt;==&gt; y in x Importcollections.CounterCounter类的目的是用来跟踪值出现的次数。它是一个无序的容器类型，以字典的键值对形式存储，其中元素作为key，其计数作为value。 12&gt;&gt;&gt; c = Counter() # 创建一个空的Counter类&gt;&gt;&gt; c = Counter('gallahad') # 从一个可iterable对象（list、tuple、dict、字符串等）创建 collections.dequedeque 是双边队列 1234567891011d = collections.deque([])d.append('a') # 在最右边添加一个元素，此时 d=deque('a')d.appendleft('b') # 在最左边添加一个元素，此时 d=deque(['b', 'a'])d.extend(['c','d']) # 在最右边添加所有元素，此时 d=deque(['b', 'a', 'c', 'd'])d.extendleft(['e','f']) # 在最左边添加所有元素，此时 d=deque(['f', 'e', 'b', 'a', 'c', 'd'])d.pop() # 将最右边的元素取出，返回 'd'，此时 d=deque(['f', 'e', 'b', 'a', 'c'])d.popleft() # 将最左边的元素取出，返回 'f'，此时 d=deque(['e', 'b', 'a', 'c'])d.rotate(-2) # 向左旋转两个位置（正数则向右旋转），此时 d=deque(['a', 'c', 'e', 'b'])d.count('a') # 队列中'a'的个数，返回 1d.remove('c') # 从队列中将'c'删除，此时 d=deque(['a', 'e', 'b'])d.reverse() # 将队列倒序，此时 d=deque(['b', 'e', 'a']) collections.defaultdict( )免去查看字典里是否有 key 的操作，如果没有直接加上 123456789101112# 普通 dictionarygraph=&#123;&#125;for u, v, w in times: if u not in graph: graph[u]=[(v, w)] else: graph[u].append((v, w))# 骚操作graph=collections.defaultdict(list)for u, v, w in times: graph[u].append((v,w)) heapq最小堆（优先队列）123456789101112131415161718192021222324252627282930&gt;&gt;&gt; l=[4,2,5,7,1]&gt;&gt;&gt; heapq.heapify(l)&gt;&gt;&gt; l[1, 2, 5, 7, 4]&gt;&gt;&gt; h=[] #定义一个list&gt;&gt;&gt; import heapq #引入heapq模块&gt;&gt;&gt; h[]&gt;&gt;&gt; heappush(h,5) #向堆中依次增加数值&gt;&gt;&gt; heappush(h,2)&gt;&gt;&gt; heappush(h,3)&gt;&gt;&gt; heappush(h,9)&gt;&gt;&gt; h #h的值[2, 5, 3, 9]&gt;&gt;&gt; heappop(h) #从h中删除最小的，并返回该值2&gt;&gt;&gt; h[3, 5, 9]&gt;&gt;&gt; h.append(1) #注意，如果不是压入堆中，而是通过append追加一个数值&gt;&gt;&gt; h #堆的函数并不能操作这个增加的数值，或者说它堆对来讲是不存在的[3, 5, 9, 1]&gt;&gt;&gt; heappop(h) #从h中能够找到的最小值是3,而不是13&gt;&gt;&gt; heappush(h,2) #这时，不仅将2压入到堆内，而且1也进入了堆。&gt;&gt;&gt; h[1, 2, 9, 5]&gt;&gt;&gt; heappop(h) #操作对象已经包含了11 函数式编程高阶函数 f=abs 函数本身可以赋值给变量，即变量可以指向函数。既然变量可以指向函数，函数的参数能接受变量，那么一个函数就可以接受另一个函数作为参数，这种函数就称之为高级函数 mapmap() 函数接受两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，，并把结果作为新的Iterator返回。 123456789&gt;&gt;&gt; def f(x):... return x * x...&gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])&gt;&gt;&gt; list(r)[1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))['1', '2', '3', '4', '5', '6', '7', '8', '9'] 感觉这个跟 filter( ） 有点像啊，filter( )接受一个是函数，一个是 list，返回一个迭代器，将返回 True 的放进去。 reduce 函数reduce( )把一个函数作用在一个序列上，这个函数必须接受两个参数，reduce吧结果继续和序列的下一个函数做累积计算。 123456789101112131415reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; def add(x, y):... return x + y...&gt;&gt;&gt; reduce(add, [1, 3, 5, 7, 9])25&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; def fn(x, y):... return x * 10 + y...&gt;&gt;&gt; reduce(fn, [1, 3, 5, 7, 9])13579 sorted( ) 函数他可以接受一个key函数来实现自定义排序。 12&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs)[5, 9, -12, -21, 36] 还可反向排序，传入第三个参数： reverse=True 12&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)['Zoo', 'Credit', 'bob', 'about'] 匿名函数 lambda x: x+x]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习笔记1]]></title>
    <url>%2F2019%2F02%2F08%2Fpython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[如果要让 Python 打印出指定的文字，可以用print( )，把打印的文字用单引号或双引号括起来。 input( )函数输入，input 返回的数据类型是 str # 开头的是注释 数据类型 整数 浮点数 正负无穷 float(&quot;inf&quot;) and float(&quot;-inf&quot;) 字符串 字符串是以单引号‘或双引号“括起来的文本。 还可以用r&#39; &#39;表示&#39; &#39;内部不转义。 12print(r&apos;\\\t\\\&apos;)&gt;&gt;&gt; \\\t\\\ [] list；( ) tuple； 方法：append( ), pop( ), insert( a, b) { }dictionary dic[’a’]=b dic.pop(&#39;a&#39;) set: key 的集合 但不存储value。 创建一个 set 需要提供一个 list 作为输入集合。 方法：add(key), remove(key), set 可以看成数学意义上的无序和无重复元素的集合 list 方法 l.count(1) 值为1的有几个 b=a[:] make a copy! string 方法 set 方法 dictionary 方法 dic.pop(key) 大小写12345678910str="www.zhstark.com"print(str.upper() )# 把所有字符中的小写字母转换成大写字母print(str.lower() ) # 把所有字符中的大写字母转换成小写字母print(str.capitalize() ) # 把第一个字母转化为大写字母，其余小写print(str.title() ) # 把每个单词的第一个字母转化为大写，其余小写WWW.RUNOOB.COMwww.runoob.comWww.runoob.comWww.Runoob.Com 判断是否是数字或字母12345678str 是字符串str.isalnum() #所有字符都是数字或者字母str.isalpha() #所有字符都字母str.isdigit() #所有字符都是数字str.islower() #所有字符都是小写str.isupper()str.istitle() #所有单词都是首字母大写str.isspace() #所有字符都是空白字符、\t、\n、\r 格式化12345678&gt;&gt;&gt; 'hello, %s' % 'world'hello, world'&gt;&gt;&gt; 'Hi, %s, you have $%d.' % ('Micheal', 99999)%d 整数%f 浮点数%s 字符串%x 十六进制整数 函数定义一个函数要使用的饭语句，依次写出函数名，括号，参数和冒号： 定义一个什么也不做的空函数，可以用 pass 语句：12def nop(): pass pass可以用来做占位符 位置参数 def power(x): 默认参数 def power(x, n=2): 可变参数 def calc(*number): 参数 number 接收到的是一个 tuple 关键字参数 def person(name, age, **kw): 命名关键字参数 def person(name, age, *, city, job): def person(name, age, *args, city, job): 命名关键字参数必须传入参数名。 特性切片123L[0:3]L[:3]L[-2:] 迭代我们可以通过 for 循环来遍历一个 list或 tuple，这种遍历我们称为迭代 ( Iteration )内置的 enumerate 函数可以把一个 list 变成索引-元素对 12for i, value in enumerate(['A','B','C',]): print(i, value) 列表生成器1[k*k for k in range(1,11)] 生成器一边循环一边计算的机制，称为生成器：generator。可以通过next()函数获得 generator 的下一个返回值。 第一种方法，把列表生成式的[] 改成()，就创建了一个 generator g=(x*x for x in range(10)） 第二种方法，如果一个函数定义中包含yield关键字，那么这个函数就不再是普通函数，而是一个 generator。 1234567def fib(max): n,a,b=0,0,1 while n&lt;max: yield b a,b=b, a+b n=n+1 return 'done' 迭代器可以被 next() 函数调用并不断返回下一个值得对象成为迭代器： Iterator。把 list, dict, str 等 Iterable 变成 Iterator 可以使用 iter() 函数： 12&gt;&gt;&gt; isinstance(iter('abc'), Iterator）True]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七牛图床链接失效]]></title>
    <url>%2F2018%2F12%2F19%2F%E4%B8%83%E7%89%9B%E5%9B%BE%E5%BA%8A%E9%93%BE%E6%8E%A5%E5%A4%B1%E6%95%88%2F</url>
    <content type="text"><![CDATA[突然发现以前博客的图片都没有了，查了一下是因为七牛的连接更改问题（我之前用的都是七牛的图床）。 找了个弥补方法的链接。懒得吧图片折腾回来了，反正也没人看=。= 在七牛新建一个存储空间还能继续用，希望七牛不要出这种幺蛾子了吧。]]></content>
      <categories>
        <category>记录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git push 重新输入密码]]></title>
    <url>%2F2018%2F12%2F16%2Fgit%20push%20%E9%87%8D%E6%96%B0%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[第一种情况通过 https:// clone 下来的，输入：git config --global credential.helper store 网上普遍推这种方案，但我没试过 这种方案的缺点在于账户密码完全明文存储在本地，不安全。 第二种情况通过SSH clone 下来的，但每次 git push 仍要输入密码。 首先检查根目录下有没有 .ssh 文件 如果有，运行 1ssh-add -K ~/.ssh/id_rsa 没有， 12345678ssh-keygen -t rsa -C "email@mail.com"git config --global user.name "name"git config --global user.email "email@mail.com"#测试ssh -T git@github.com]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[添加路径到 PATH 的问题]]></title>
    <url>%2F2018%2F10%2F17%2F%E6%B7%BB%E5%8A%A0%E8%B7%AF%E5%BE%84%E5%88%B0%20PATH%20%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[该文章是记录我在捣鼓 pandoc 的时候出现 bug 并解决的过程。 由于我平时喜欢用 markdown 写作，如何编辑数学公式就成了难题。通过 pandoc，我可以在 markdown 里用 LaTeXiT 编辑公式，通过 pandoc 就可以导出显示公式的 pdf 了。但在我导出的时候，会有提示pdflatex not found. pdflatex is needed for pdf output.。我之前已经下载过 MacTex，所以pdflatex这东西我是一定安装好了，通过搜索，发现应该是路径没有导入 PATH 的问题。但是网上的教程对我来说并不管用，通过一系列折腾，终于搞清楚了问题所在。 当我们安装了新的底层程序（如 MacTex，npm），需要将其路径放到 PATH 中，在很多网络教程中，都是使用的该语句： 1sudo nano /etc/paths 将路径输入进文件，或者是： 1echo 'export PATH="/usr/local/bin:$PATH"' &gt;&gt; ~/.bash_profile 然后用echo $PATH 查看，在某些情况下，该PATH 变量并没有任何改变，打开/etc/paths 文件，看到路径确实添加进去了。这是怎么回事呢？ 这时候echo $PATH 所显示的路径其实属于 bash_profile，我们用文本编辑器打开该文件，看到里面有1export PATH="/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin" 我们只需要将所要添加的路径续在&quot; &quot; 后面就可以了，记得用:与前面的路径分开。eg：export PATH=&quot;/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/Library/Tex/texbin&quot;然后重启终端，再用echo $PATH，就发现已显示添加的路径。]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中科院科研项目总结]]></title>
    <url>%2F2016%2F10%2F08%2F%E4%B8%AD%E7%A7%91%E9%99%A2%E7%A7%91%E7%A0%94%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前三部分为扯淡，第四部分描述了这个课题的过程步骤，第五部分为一些小感悟，第六部分是小福利。 先扯扯淡 一为期五天的科研营结束了，有收获，也有遗憾。 这五天确确实实学到了很多东西，不论是概念上的，还是方法、工具使用上的。终于大致理解了机器学习有哪些方法，基于的原理，并切实应用了 SVM 分类器。大二调了一年参数，本以为会了机器学习就可以让电脑自己搞出成果来，结果还是要自己再去调参数，真是蛋疼。 基于各种原因，最终我们并没有切实的完成这个课题，目前只是从一幅图片里提取出了车牌的区域，还不能让电脑认识车牌上的字符，写入文本。日后要补完，最好再整理重构一下。（一不小心就立了 flag = =） 短短五天，除了第一天，每天都是凌晨一点多才能睡。第二天9点上课，中午没有午休，却从没有像在学校一样听着课不小心就睡着。也许是老师讲课水平高，也许是这些知识确确实实吸引了我，激起了我的兴趣，总之，在这种强度下没有出现过上课睡着的情况甚至连打瞌睡都没有，对我来说，史无前例。 二最后一天，走前在计算所里面简单逛了逛，发现其一楼布置的还是很赞的。内部有买咖啡的地方，应该是因为在假期吧，里面无人营业。 咖啡店外面，提供了好长一排可以读书讨论的地方，沙发座椅，环境布置的很不错。 我认为一个公司（/机构）里的厕所设置可以在很大程度上代表该公司（/机构）的硬件水平。不得不说计算所的厕所设置的还是很人性化的，至少在我所见过的建筑中，计算所的最贴心。内部采取的是人体红外感应，水龙头的距离感应特别靠谱，不像其他地方的要晃半天手才感应到。每个厕间都有放东西的小托盘，有厕纸。暖暖的，很贴心。 好久之后才发现，原来大名鼎鼎的搜狐就在旁边 三这次做东西最开心的莫过于终于不用 TMD 开虚拟机用 Windows了！不知要剩多少心，感觉自己又能多活五分钟。以后选专业就要选这种能全程使用 Mac，不像搞单片机那样离开 Windows 就 gg，Mac 给我的美感，舒适能让我坚持更长时间的工作( ⸝⸝⸝⁼̴́⌄⁼̴̀⸝⸝⸝)。工具嘛，必须用顺手的才有效率。 可惜的是没有带转接头，无法用自己电脑，展示PPT的时候只能讲Keynote 转为 pdf格式了。 四 以上都是扯淡以下来稍微专业点的干货有时候我会提出一些简单的问题，有兴趣的读者可以思考一下 认识个车牌看似简单，但是要把这个检测识别做的足够强大，有更强的普适性，还是有很多工作要做的。单是对鱼眼镜头图像的校正处理就能发硕士毕业论文了。目前做的没那么复杂，只是对正视视角的车牌处理。但还是会分割为好多问题。 得到一幅图像，我们要通过一定的方法找到可能是车牌的区域，即选择符合一定规则的框框，作为车牌的“候选人”，下一步，便是在这些“候选人”中选择最合适的人选，即找出真正的带车牌的框框。该人选可能没有那么了解当前的业务，所以，下一步便是对选好的人选进行培训，即对所选的车牌区进行进一步优化处理，以便进一步识别出上面的字。最后，就是把一个字一个字都扣下来，进行模板匹配，从而将车牌上的字从“图像”的印象转为“字符”的印象。这是目前所差的步骤了，当然，在完成的过程中肯定还会遇到各种各样的问题，已经习惯麻木了_(:3」∠)_ 4.1读取图像就是从文件里找，当时老师要求做一个简单的 GUI 界面，我一脸懵逼的就去学做 GUI了，结果其实只需要一个内带的函数就可以自动跳出 GUI 界面让你选择文件。 4.2可能是车牌的区域怎么找嘞？方法很多，我们目前用了两种，第一种是通过颜色提取，因为车牌是蓝色的嘛（暂时只考虑蓝色车牌），那么只需要把蓝色的区域提取出来就是嫌疑牌喽。怎么提取呢？一张彩图是通过几个通道的数据合成出来的。比如 RGB 的图片格式，就是通过 R(red), G(green), B(blue)三个代表三种颜色的通道合成出来的。如果是 RGB 的图片格式的话，我们就可以选择 R G 通道数字小，B 通道在一定范围的区域作为嫌疑牌。不过目前我使用的是 Lab格式，测试过 hsv格式，效果不好。没有测试 RGB格式。找到嫌疑牌后，我们就把这张图片二值化，即把嫌疑牌说占的区域全部变成白色，其他变成黑色。（为什么要二值化呢？） 第二种就是通过轮廓提取，对于一张灰度图来说，色差明显的地方我们可以视为边缘。这一步便是先利用 RGB 变灰度的经验公式对彩图进行灰度化，然后通过一定的算法对该灰度图提取边缘。（为什么不直接对彩图提取边缘呢？）提取后，凡是边缘的地方就是白色，不是边缘的就是黑色。因为车牌是白边蓝底白字，所以这种方法把车牌选中的难度不大。 4.3现在我们得到了一张只有黑白两种颜色的图片，那，来回答为什么对通过颜色提取的图片进行二值化的问题。是为了和轮廓提取法相统一吗？通过轮廓提取就是二值化后的了。并非如此。二值化是为了方便我们的这一步处理。 因为只有黑白两种颜色，所以处理起来自然简单的多。所以这也是我们化简问题的一种方法。 对于得到的黑白图像，我们再对其做“腐蚀”或“膨胀”或既有“腐蚀”又有“膨胀”的处理（图像处理上的专业术语，放张图片感受下）。相当如对图片的一步润色。 不管是是通过轮廓还是颜色，对选的嫌疑牌的大小，形状都没有限定。所以有可能有很多小的零散的点，类似于噪声，总之那些一定是对我们没用的东西，所以我们再把那些特别小的点除去，这样，我们就得到了质量更高的嫌疑牌。（类比于海选第二阶段，在淘汰掉一群倒霉孩子） 4.4海选结束，我们得到了少数几个很有可能是车牌的区域，当然，我们需要的是他们的坐标信息。从而在原图像中把这些区域扣出来。 下一步，就是把真正的车牌选出来，这一步也是这个课题最有趣的部分。它需要用到机器学习的方法，让机器学着认识车牌。 机器毕竟不是人，它算的再快也没用像人类一样的抽象思维，它只能处理数字信息。那么如何让电脑认识车牌就是一个大问题。 既然电脑认识数字信息，那么我们就从图片上提取出数字信息呗。这项课题中我们便是提取图片的 HOG（histogram of gradient）特征。记住了一个图像的 HOG特征之后，那电脑就认识这幅图像了。 但是，你认识了这副图，下一幅类似的不认识了也不行啊，不能只认识黑体的“1”转为斜体“1”就一脸懵逼呀。 这时候，就要用到强大的 SVM分类器了。这一块之前的文章有过介绍，有兴趣的也可以网上查找资料，不再赘述罢。一句话：「把”是车牌”的 HOG特征和”不是车牌”的 HOG特征输入电脑，电脑以后就知道”啥样的是车牌，啥样的不是车牌”了。」 这样一来，我们把之前选好的嫌疑牌送给电脑，电脑就认得这些嫌疑牌中的真车牌了。 4.5这时候我们得到了的带车牌的区域，而我们最终的目的是要识别出上面的字。所以我们还有对这块区域进行进一步处理，方便我们更容易认识上面的字。 如果这时候的车牌是有小倾角的，我们对其进行 radon变换，将其摆正。然后再对其进行削边，凡是不包括字符的区域全部丢掉，丢掉！ 终于，我们得到了包含字符的最小区域。也是我目前做到的阶段。再下一步，就是认出上面的字了。 4.6电脑不够机灵，多个字放一起它认不得，得把单个的字分离出来，然后对每个字进行模板匹配，从而达到认识字的目的。这一部分等我完成再写，没有实际操作，纸上谈兵不靠谱。 五做这个项目有哪些感悟呢？ 第一个是「维度」的概念，在 SVM 分类器中，对一个较复杂的情形做线性分割的方法便是「升维」。升到更高的维度后观察，非线性关系就转变为了线性关系，很多问题就可以轻易地解决了。就像我们身处三维空间就能很容易的解决二维平面的问题，而对三维空间中的物体处理起来却有时候力不从心，对四维空间中的东西……等等，什么四维空间？ 第二个是「换位思考」，「换位思考」不仅仅是指与人换位，还可以与机器换位。在这个项目便是试着按照计算机的处理特点去思考。计算机没有感性思维，他只能处理数字信息，那如何才能让计算机像人类一样呢？我们就试着把我们说看到的东西转换为数字信息，一张张图片不就是一个个二维或三维的数组嘛，我们看到的什么颜色又对应数组中怎样的数值？试着从计算机的视角去看待事物，找到计算机与人相连接的桥梁，我们就知道如何让计算机像人一样看待事物了。 第三个是「搜索引擎是亲爹」。这个项目没有规定教材，不会的知识全靠网上搜，Google 百度用起来。我们处于「学习」阶段，不同于「研究」，我们遇到的问题之前都有还多人遇到过，我们走的路之前很多人也走过，所以，在这个阶段，互联网上有大量的资源可以帮助我们解决问题，搜一下就能找到，方便快捷。所以，检索能力很重要。 第四，「数学就是亲爷爷」。 六这个项目我一定会完成，但是时间不好说，两周一个月都有可能。如果你对此有兴趣，可以回复“「车牌识别」+（你的邮箱）”，当我完成的时候会把全部代码上传到 github，并发邮件通知你 :）]]></content>
      <categories>
        <category>Proactive</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[中科院科研项目第三天]]></title>
    <url>%2F2016%2F10%2F03%2F%E4%B8%AD%E7%A7%91%E9%99%A2%E7%A7%91%E7%A0%94%E9%A1%B9%E7%9B%AE%E7%AC%AC%E4%B8%89%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[一今天晚上终于找到一家合适的咖啡店上自习，有网，安静。中科院不提供自习处，十一假期好多店又关门，每天晚上我们都是无家可归的状态，到处找地方蹭网做作业。而且，这家店老板的闺女挺漂亮哒，态度好，声音也好听，嘤嘤嘤。 项目一共五天，今天已经是第三天了，还有两天结束，周围开门的饭店已经被我吃遍了。。。。感觉每逢短期假期就是我遭罪的时候，不回家，然而在外面各个服务业又停业，没地方吃，没地方去，只有床才是最温暖的陪伴。 二今天的作业是利用 HOG 提取体特征，将训练集送入 SVM 分类器让其学习，产生一个模型，再利用学习后的模型对我们需要分类的样本进行分类。 HOG 我还没太仔细看，解释不清楚，至于 SVM，可以看我上一篇文章最后的 gif 录屏，不要嫌那个动的太快，腾讯只让发2M 以下的 gif，我也没办法。其实只要我们上下摆头的速率和那张动图变化的速率一样，就能看清了。不难，我试了7次就合上拍了，还挺清晰的。 就我们目前做的课题来说，就是送一堆车牌的图片给电脑，并告诉他「看清楚了，这是车牌！」再送给他一坨不是车牌，但他可能以为是车牌的图片，告诉他「长点即兴，要是认错了发你跪键盘！」然后电脑就赶紧认认真真地去学习车牌长什么样子，不长什么样子。 等他学会后，吸收，消化，排泄，拉出一个模型便便💩，不屑地告诉我「我这便便能认识车牌了，你把这便便扣在有车牌的图片上，它把车牌给你熏下来。」 我如珍似宝地双手托着这宝贵的便便，使劲扣在一张图片上，它还真把车牌给熏下来了。我熏了一张又一张，发现，这便便味道不够足嘛，有的车牌还是熏不下来，唉。回去罚他跪键盘，但是发现作为一个穷逼，我并没有键盘让他跪。所以特此征好心人送我一个 cherry 键盘来让电脑跪，感激不尽。 三其实让电脑学习还不是简单的给他资料他就能学。电脑，这个高贵的东西，肯定有点小脾气不是，所以你得对他性子才行，他喜欢吃苹果，你非得喂他吃榴莲，他肯定轻则罢学重则 down机啊，榴莲再贵也不行，不对电脑口味。 所以能，咱得找到电脑喜欢啥，给他点啥他才能更好的学习。电脑没长牙，那我就送他两个参数意思意思呗，他不告诉我他喜欢吃啥很是讨厌，我得一个个试，这电脑配置低，性格墨迹，试一次要好长时间，TMD，老子有钱了买个最高配，拿一筐苹果塞他嘴里，让他使劲吃，吃完使劲学。苹果不管用就塞梨，梨再不管用，那我只能破费请他吃个海底捞了。 目前我还没兴致找他口味，所以他现在拉出的便便质量也就那样吧，还凑活能用。]]></content>
      <categories>
        <category>Proactive</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[中科院科研项目第二天]]></title>
    <url>%2F2016%2F10%2F02%2F%E4%B8%AD%E7%A7%91%E9%99%A2%E7%A7%91%E7%A0%94%E9%A1%B9%E7%9B%AE%E7%AC%AC%E4%BA%8C%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[学习乃万恶之首其实我也想度假 一昨天做作业搞到凌晨一点半，所以没有及时发文。 今天作业量小些，先补写一下~ 在计算所上课到下午四点半，下课就不让待着了，待着那里也没wifi。堂堂计算所 竟然不提供全楼 wifi 覆盖，真是说不过去，太掉价了。 而中科院周围跟空城似的，假期真是积极响应党和国家的号召，认认真真休假，找了两家咖啡馆都关门，现在我们下课后的情况就是到处找地方自习蹭 WiFi。 先放一下计算所的照片吧， 内部布局看起来挺大气的，那些座椅在一楼大厅的一侧，在这喝杯咖啡聊聊天还是蛮有韵味的。大门有门禁，负责门禁的是个很帅气的小哥，恩，真挺帅气的。地下一层就乒乓球场地，球台挺好的，空间也够大，本来冲着这点就考虑以后到这找工作了，但是看了他的 wifi 情况还是算了。 二昨天作业算是真正开始接触机器学习了。之前都是使用 MATLAB 对图像进行处理（在此不得不感叹 MATLAB 之强大），但是处理后并不能完全把车牌区域提取出来，经过这种程度地处理电脑还很容易把非车牌区域认为车牌区域，毕竟它也不知道那到底是啥区域，只是判断其颜色，大小，就提取出来了。 要想变得厉害还是得学习！ 机器学习是怎么来的呢？有一群心理变态的人在一起读书学习的时候看着电脑在那无聊的待着，就想：「这电脑怎么能这样呢？要么玩游戏，要么就放点 dirty movie，毒害人类！要么就在那闲着，浪费生命！这可不行，你得学习，不学习不成机器。」于是他们就发明了机器学习，这样电脑也能快乐的陪他们一起学习了。 以上纯属扯淡 用 MATLAB 提取出几块可能是车牌的区域还是不行啊，得让电脑知道哪块才是真正的车牌区域才行。但是人们又懒得一点点教电脑怎么识别哪块才是车牌区域，所以，让电脑自己学去吧！老子才不管你，学不好就摔你！ 学习得有方法，于是那些大（bian）神（tai）善性大发，打算教给电脑一些学习方法，其中一种叫 「SVM（Support Vector Machine）分类器」。 SVM 翻译过来叫支持向量机，他叫“机”，但他不是机器，它属于机器学习中的有监督学习模型。（电脑学个习还得被监督呢？谁监督你啊呸）刚来第二天就要接触高大上的机器学习模型，还得做 ppt 展示？我的表情是这样的 但该学还得学啊，电脑都要学习了，咱不能比不过电脑啊。昨天看资料到12点多，终于感觉理解的差不多了，于是简单做了个 keynote，麻溜睡觉。]]></content>
      <categories>
        <category>Proactive</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[中科院科研项目第一天]]></title>
    <url>%2F2016%2F10%2F01%2F%E4%B8%AD%E7%A7%91%E9%99%A2%E7%A7%91%E7%A0%94%E9%A1%B9%E7%9B%AE%E7%AC%AC%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[趁着他们都去度假了，看看我们这几天能够做成什么 零昨天从济南千里迢迢终于来到了北京，感谢梦瑶大头曹同学不远万里去车站接我，虽然等了好久= =！ 实习地点在中科院计算所，住处在计算所北边不远处，下了地铁离住处还有1.6km，一路走的好辛苦，在路上见到了中科院的两个研究所，当时我就惊呆了 大名鼎鼎的中科院研究所就长这样？ 赶上我老家危楼了都(╯°□°）╯︵┻━┻中科院怎么这么不注意自己的门面，简单翻新一下，冲刷一遍油漆也不至于这么磕碜，这样看起来给人的感觉简直快穷过我了。还没开课心先凉了一半，不过晚上去计算所踩点发现那边的群楼还是蛮高大上的。今天忘记了拍照片， 一今天上课，五天要做的项目是“车牌识别系统”，工具 MATLAB，所以时间还是很紧张，今天的作业做到晚上10点40，终于才能回住处开始写文章。一起培训的一共只要五个人，我和一个小哥一组，MATLAB 都没怎么用过，所以做作业的时候简直一脸懵逼，发现 Google 就是亲爹啊！ 机器视觉现在用的也是机器学习，最流行的是当前大热的深度学习，我们最终的任务也是给电脑一个训练集，等他好好学习，就认识车牌啦！ 电脑与我们无冤无仇我们却还逼他好好学习，真是人性的沦丧，道德的丢失╭∩╮（︶︿︶）╭∩╮ 任务重也好，课下多学点东西，这次假期结束熟练 MATLAB 应该不成问题了吧。 今天好累，就先写到这]]></content>
      <categories>
        <category>Proactive</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一个科学方法论]]></title>
    <url>%2F2016%2F09%2F19%2F%E4%B8%80%E4%B8%AA%E7%A7%91%E5%AD%A6%E6%96%B9%E6%B3%95%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[“哎，你们单位今年中秋发的啥？”“发的天空二号～” 「天空二号」在中秋节成功发往太空，可喜可贺，也辛苦了工作人员。「天空二号」能够发射成功，离不开控制论的发展与应用。而控制论中的一个重要概念「负反馈」起到了举足轻重的作用。 「负反馈调节」是控制理论中的重要组成部分，而这一思想，通过「它还能用在哪」的思考后，我发现在现实中，不仅有很多事物正在应用它，我们也可以主动用这一科学方法论来指导我们的行动。 什么是负反馈拿今年中秋节发射的天空二号来说吧。天空二号发往目的运行轨道，不是最开始就朝着目标方向发射出去就不管了，而是在发射的过程中，火箭不断地对自己的姿态进行校正，让自己朝正确的方向飞行，而之所以能这样做，就是因为它可以检测自己当前的飞行状态与目的地的关系，由此来校正姿态使自己不会跑偏。这个「检测」—>「校正」的动态过程便是负反馈。 想想老鹰捉小鸡，老鹰在天上飞，看到地上有一只萌萌哒的小鸡，老鹰“嗖”地一下俯冲下去，准确地捕捉到了小鸡。显然，老鹰不是按照事先计划好的路线飞行的，因为受各种随机因素的影响，如果老鹰从空中确定方向和速度等不再更改，那么它是不会抓住小鸡的。 老鹰看到小鸡后，马上估算一下相对位置和大致距离，然后选择一个大致的方向飞向小鸡，在这个过程中，老鹰一直用眼睛盯着小鸡，报告大脑它与小鸡之间的位置关系，由此不断调整飞行方向和速度，最终准确捕捉到小鸡。 我们简单分析一下这个控制系统，老鹰在眼睛盯住小鸡的同时，也注意到了自己的位置，并将两者位置进行比较，图中的“Θ”是一个比较器，经过比较后的信号代表老鹰的位置与小鸡的位置的差值，我们称其为“目标差”，眼睛主要是接收这种目标差信息，并把它传递给大脑。大脑指挥翅膀，从而控制老鹰向目标差小的方向运动，这个过程重复进行，构成了老鹰捉小鸡的连续动作。这里最关键的一点是大脑的决定始终使老鹰的位置向减小目标差的方向改变，控制论中把这类控制过程称为「负反馈调节」。负反馈调节的本质在于设计了一个使目标差不断减小的过程，通过系统不断把自己控制后果与结果相比较，使得目标差在一次一次控制中慢慢减少，最终达到控制的目的。 它是怎么工作的 我们把老鹰的动作看成一系列俯冲动作的连续，每一次俯冲都可以看成对自己位置的控制。老鹰的控制能力是有限的，他不可能一次到达目标，老鹰从高空冲向小鸡，它这一次飞行的能力只能让它达到 B 区域，不能抓住小鸡。如果在一次俯冲后，老鹰用过判断，反馈，马上进行第二次动作，将范围再次缩小到 A 区域，由此往复，精度越来越高，最终使老鹰准确地捉到小鸡。由于实际上老鹰的俯冲动作是连续的，所以我们看起来就像是一步到位。 对我们有何指导意义导弹、火箭、卫星其实都用了这套方法，但这些高大上的东西对我们来说好像并卵。其实我们生活中，我们身边也有好多这个方法的应用。比如我们最熟悉的 app 迭代，为什么一个 app 会一次又一次的更新，其实就是在一个版本发布后，开发者从用户那里得到反馈，反馈指导开发者们对产品进行修改，再发布，再反馈，循环往复，使一个 app 越来越好用。 但我们不是移动 app 开发者，那么我们又能用这套理论做什么呢？ 学新东西，先做起来看知道为什么老师总说“先用起来”，而不是“学起来”吗？这就有「负反馈」的理论在里面。 做起来看，我们做一件没有做过的复杂的事情，总不能把一切安排的周周道道的，客观事物总是在不断变化的，意外的情况也在不断发生，即使我们事先考虑得再周密，也会遇到一些不可预测的麻烦来干扰我们。因此最好的办法就是干起来再说。一边干一边观察，（所以不能闭着眼干，要注意出乎其外，注意反馈）随时修正自己的行动和方法，采取一步一步的办法逼近目标。 我们在最开始学习一个陌生的事物时总是感觉无从下手，就像老鹰盘旋在上空，它还没有发现隐藏在树林里食物。我们要做的就是随便找一个入口下手，可能我们最开始的计划就是从豆瓣中找一本评分最高的书，看上他那么几章，然后我们就发现我们要抓的小鸡了。 不断修改计划 之前我们总是一开始就设定好目标，立马列好计划，然后按着计划去行动，结果总是失败的，或者是失败居多，其实不是我们计划列的不对，不合理，不是我们列计划内容得问题，而是我们列计划方式的问题。 一开始我们就像那个在天上刚刚看到小鸡的老鹰，我们发现了小鸡（设定好了目标），然后找到一个方向朝着小鸡俯冲过去（设定好了计划并去执行），然而如果过程不加调整，你能抓到小鸡的可能性是很小的，风的影响，树叶的干扰，小鸡在某个时间发现了老鹰，到会让你捕捉失败。即你第一次设定的计划是很难达到预想的效果的，有种种随机因素的影响，以及一开始设定计划时也可能会忽略某些因素，都会让你前进的方向并非直至目标。 所以，在行动的过程中要不断观察周围，根据实际情况再对原计划进行改动，从而行成负反馈。这样，我们前进的方向才能越来越朝向我们最开始设定的那个精确点，而不是落到周围圆内的某一点。 以前父母总是教育我们： 定好目标，列好计划，然后严格地按照计划去执行 其实，这样是 TM 绝对不会完成目标的，除非这个目标是小而近的，就像你已经到达 A 区了再捕捉小鸡。 实现任何一个稍微长远一点的目标，或者进入一个十分陌生的领域，我们最开始列的计划是不能一成不变的从头执行到尾的。因为我们对其了解不够，我们的计划不够完美，不够贴合现实，我们需要在前进的过程中获取更多信息来指导修正我们的计划。 只有不断地获得负反馈，不断依靠反馈对自身进行指导，我们才会越来越贴近最终的目标。 想想还能用在哪？ 演讲者观察听众调整演讲 老师观察学生调整上课节奏 打球过程中根据球员状态和对手水平调整战术 ……]]></content>
      <categories>
        <category>Proactive</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《如何高效学习》读书感悟]]></title>
    <url>%2F2016%2F07%2F31%2F%E3%80%8A%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%AF%BB%E4%B9%A6%E6%84%9F%E6%82%9F%2F</url>
    <content type="text"><![CDATA[前言读书如果仅仅是「读」，那是远远不够的。「读」只是简单地「输入」，有时候甚至连「输入」都谈不上吧。「输入」本身没有任何作用，就像如果你有了很多很多钱，只是把它藏起来，压箱底，那这些钱是没有任何作用的，你不去花掉它，不去利用它，这钱甚至连垃圾都不如罢，垃圾还能回收利用呢。（当然，应急钱除外） 有了「输入」之后呢？ 要思考，将信息进行处理。原材料有了，把它加工出来才有价值。「思考」这一步是很累的。有的人读书很快，而且感觉读书很轻松，就是因为他们没有「思考」这一步，读完了，就算完了。感受自动分泌的多巴胺给我们的快感很容易，而主动思考就不简单了。没有「思考」就只能享受生动热烈的内容场面本身带来的快感，无法感悟里面所蕴含的理念、精神。所以，读书应该不是轻松加愉快的，而是很累的一件事。特别是读一本好书，一遍往往不能汲取他的精华，因为人总是会有遗忘，总是会有某些时刻思维不够敏捷，以至于当时无法感悟那部分内容奥妙与精彩。 「思考」之后呢？将浓浓思想如泉涌化为内力，总有一天练就九阳神功？所谓「学以致用」，思考之后当然要「实践」，想想如何使用它，至少，如果觉得很有价值，可以把它分享出来。知识，传播的越广越有价值。另外，在「实践」的过程中，又会有一些事情发生，反馈，使你再次回到「思考」这步。刺激你“开天眼”。 用计算机的方法说，可以是：「输入」-「处理」-「输出」 为什么讲一本书的读后感会扯到我对读书的看法呢？因为这本书讲的学习方法，跟我上面讲的很相似，或者说，他的方法更加细致全面。读这本书，我个人建议慢慢地，思考着读。 在「输入」阶段，就大学生阶段而言吧，大多数大学生的「输入」来源就是教材和网络了。但是大多数大学教材都是自己大学的教授所写，不敢说不好，至少有很大的局限性。所以我建议买一些其他口碑好的教材，这其实就是增加「输入渠道」，让自己获取的信息更加准确，全面，优质。 正题先解释一下书名吧，原文是 『 Learn More Study Less 』，“learn” 和 “study” 都是学习，但 “learn” 强调的是结果，“study” 强调的是过程。所以，这个书名的直译应该是『花更少时间学到更多东西』。而这就产生了效率。 简单讲，这本书就是讲了一些可以帮助我们快速学习概念和相应的方法论。这些概念中有一部分我也确实发现自己应用过，但是没有系统的整理和总结。而其方法论中，有一些我在应用，有一些我从未意识到可以这样，还有一些更高级的方法论，我甚至发现在«生活大爆炸»中的谢尔顿的一些方法就是如此。 一. 思想有时候一本书其实就是讲一句话。比如《把时间当朋友》只讲两个字「积累」，《挤挤都会有的》只讲一个字——「挤」。 我认为这本书其实也可以压缩为两个字：「联系」。并提出了一个概念：「整体性学习」。之前我接触过一个概念，叫「系统性学习」，「系统性学习」强调要把一个学科所学过的知识点上下联系起来，形成一个系统，你的思路可以在这个系统里跑通，但并不强调各个系统之间的关联。 而「整体性学习」思维更加强大，你的程序(思维)不仅要在这一个学科的「系统」里跑，还要跑到其他学科的系统里。正所谓融会贯通。有一种思维又高了一个维度的感觉。 简单说，「整体性学习」也很像分布式网络： 只不过所链接的不再是网络节点，也不是人，而是一个个的概念，知识点。当学习了一个新东西，要想着如何把他和之前懂得的东西建立联系，甚至要跨界跨学科建立联系。这样，在你试图将这些知识联系起来的时候，你不仅加深了对两个系统的理解，有时候还会惊喜的发现自己感悟出了新知识。 作者介绍了三个整体性学习的主要“观点”（总觉这个翻译不太合适）和类比于做饭而产生的五个顺序步骤。 不过最后又增添了第六个步骤——测试。是问自己几个问题。个人感觉颇为收益，每次学习新东西的时候都可以问问自己，现摘录如下 获取阶段的测试——我以前看过或听过这个知识吗？ 理解阶段的测试——我理解知识的含义吗？（至少是字面上的意思。） 拓展阶段的测试——我知道知识从何而来，与哪些知识有关系吗？ 纠错阶段的测试——我删除了那些不恰当的联系吗？我删除了那些错误结论吗？ 应用阶段的测试——我将知识用到实际生活中了吗？ 这本书讲了几种思考方式记忆方式，使用了大量的比喻和类比。其实比喻和类比本身就是很强大的学习方法。 有些方法是我们耳熟能详甚至听腻掉的，比如记公式要知道公式的“所以然”，理解公式里每个字母所代表的含义。以前我总是不以为意，心想这该多累多麻烦啊，那些天才肯定有更好更方便的方法。最终发现，那些天才也是这样罢。但这种方法并不省时啊，相反我要花费很长时间才能理解这个公式的由来和这些fucking字母的含义。我现在认为是因为他们从小如此思考，已经训练出了比我们更快的思考速度。当然了，我相信我们通过长时间使用这种思考方法，也可以加快我们的思考速度和理解速度，一切都可以练出来。 现实版钢铁侠 Elon Musk 也说了，他最赞同的思维模式是 “First principle thinking”。 在TED的采访中，他坦言自己最赞同的思维模式是 “First principle thinking”。 “First principle thinking” 的详细解释和如何运用我会在另外的问题专门回答。简单说来，First principle thinking 就是从事物最基本的公理为出发点来进行推导的思维方式。其对立的方法是 Analogy（类推法），简单说来就是别人或者其他事物如何如何，所以我也要如何如何。 举例说明：“现在我有1万刀的现金想投资股票，我应该买什么股票？” Analogy ：“别人家之前买了这几支股票，赚了不少，或者我旁边有个股票大神也买了这几个股票，赚了，所以我也准备买这几个股票。” First principle thinking：“首先去弄明白股票的原理，看清股票涨跌的本质，然后分析公司的背后价值，接着根据自己的需求，看自己是想长久投价值，然后在A股市场利用趋势捞一波。当然也有可能，在分析过程中发现股票市场的风险大小超过了自己的承受范围，从而放弃投资股票。转而杀入债市或者定期投资等。” 节选自知乎专栏-覃超帝国兴亡史链接点这里 牛人的思维方式总是类似的。想想小时候嫌麻烦懒得思考，幻想有什么奇技淫巧能轻松愉快地记下来，最终不过是死记硬背甚至打小抄真是可笑。哪有什么奇技淫巧，脚踏实地才是王道。 二. 方法作者将信息分类，针对不同类别提出了不同的技巧来记忆。 作者介绍了四个部分的方法： 获取知识 快速阅读 笔记流 联系观点 比喻 内在法 图表法 随意信息的处理 联想法 挂钩法 信息压缩法 知识扩展 实际应用 模型纠错 以项目为基础学习 具体技巧就不大段摘抄了，在此之摘录一些我个人认为很有用的问题或方法。 进行积极阅读时你需要记下： （1）这一节中主要观点是什么？（2）我怎样才能记住主要观点？（3）我要怎样将主要观点拓展开以及应用它。 通过问自己这些问题，回答清这些问题，可以让自己真正地“吃透”文章的内容 怎样进行内在化 （1）明确你要内在化的概念。这是一个生物过程，还是编程中的函数或者是一个数学概念？ （2）从建立脑海中的图像开始。如果你不习惯内在化，可以先试着在纸上画出概念的粗略图，多次尝试后，你就会直接在脑海中想象了。 （3）脑海中的图像是静态的，还是栩栩如生的动态场景？掌握一个行列式需要好几个步骤，所以要让图像动起来，就仿佛在看一部电影一样。 （4）现在开始加上其他感官。试着用手去拿它，去摸它，去打开它，去嗅它的味道，去听它的声音，动用你身体的所有感官，将所有的感觉与运动的图像相联系。 （5）加入更多的感觉或情感。 （6）不断重复和优化图像，直到你一想到它就能很快地回忆起知识。 在«生活大爆炸»中，谢尔顿曾说自己脑中呈现了高清图像，在帮拉杰看观测数据时，他分分钟找到了异常数据，因为质数是粉色的，还有什么气味（具体记不清了）。这不就正是内在化么。这种丰富而又强大的联系极大地帮助了我们记忆与理解问题。 三. 费曼技巧 费曼的一生就是个大写的牛逼，是我最崇拜的现实人物之一。如果想了解这个疯子可以阅读下面的链接： http://www.zhihu.com/question/23916191/answer/26092786 下面是费曼技巧的流程： 第一步：选择要学习的概念首先选好你打算深入理解的概念，拿一张空白纸，在最上方写下概念的名称。 第二步：设想你是老师，正在试图教会一名新生这个知识点这一步你要假想自己费尽口舌让一名毫无这方面知识的学生听懂，并把你的解释记录下来。这一步至关重要，因为在自我解释那些你理解或不理解的知识过程中，你会理解得更好，而原先不明白的地方也得以理清。 第三步：当你感到疑惑时，返回去吧每当你碰到难题感到疑惑时，别急着往下走，学习不是单行道，回过头来，重新阅读参考材料、听讲座或找老师解答，直到你觉得搞懂了为止，然后把解释记到纸上。 第四步：简单化和比喻如果你的解释很啰唆或者艰涩，尽量用简单直白的语言重新表述它，或者找到一个恰当的比喻以更好地理解它。 其实除了「内在化」以外，「教」也是一种很好的学习方法。「教」也可以帮助自己理解问题，更重要的是，在教授的过程中，我们必须对每一个知识点都很熟悉，这时候只是感觉自己理解了是远远不够的，只要理解透彻了，我们才有能力将其清楚地表达出来，让别人明白。不记得是从哪看到的了：真正的大师讲出来的相对论可以让保姆听得懂。自己理解是一个阶段，而能清晰表达出来就是另一个境界了。这也是为什么那些爆满的课堂的老师都是大师级人物的原因。在自己教授自己的过程中，我们很容易发现自己知识的缺失。 费曼技巧中的第二步，有一些 “元编程” 的意味。自己教自己，像极了程序员桌子上的小黄鸭。 其实所谓的「学习效率」，我认为是一个伪概念，就像「阅读速度」一样，其实「阅读速度」的本质是「理解速度」，理解得快，阅读得必然快。不然你说怎么叫 “读的快”？眼珠盯着一个个的字转得快？手指一页一页翻得快？你看了字不一定算阅读，你翻了好多页也不一定叫阅读，只有理解了文字所表达的意思，才算阅读。而「学习效率」的本质我认为应该是「思考速度」。要学懂一个东西我们需要理解，需要用到联想，需要纠错，需要应用。而这些都需要我们极力思考才行。费曼技巧没有提供什么捷径，相反最开始使用我们会发现非常吃力，因为需要我们思考的地方太多。而当我们习惯用这种方法思考后，就会发现 “学习速度” 快了好多。 部分方法摘录书中最后讲了一些方法和理念，一部分我感觉非常好，值得一试，就摘录如下分享给大家。 周/日目标体系周/日目标体系是我知道的最好的对抗延迟的方法，办法很简单： 1.每周周末，列一个清单，包括所有的任务、作业以及你想在下周完成的读书和学习活动。除非在一周内出现意想不到的事情，否则你就有责任完成这个清单，不过也不必超过清单所规定的任务。这样做就把无限的工作分割成在一周内可以完成的子任务。如果这一周特别忙碌，你可能会推迟完成任务。如果这一周很清闲，你可能会提前完成任务。 2.每天晚上，检查周计划，列出每日目标清单。下一步是将每周的工作分配到每一天，你要确保完成每日的工作清单，但是不必超过它。 周/日目标系统有什么好处？（1）可以缓解你作决策的应激。你只需检查清单，就明白是否完成。（2）防止你做一项大任务时耽搁不前，依赖每周和每日目标清单，而不是截止日期，你会有时间紧迫感。（3）帮助分配你的工作量。通过制订计划，你可以将工作适当分配到周和日，不需要考试前熬通宵而前三周一个字不看，你可以细分工作。 提髙注意力阈值。注意力阈值就是指集中完成某项工作的最长时间，超过这个时间，注意力就急剧下降。通过不断接受越来越多的批处理，你可以逐渐提高你的注意力阈值。阈值越高，表示能一次完成的工作量也越大。 现在都流行什么番茄工作法，一次工作25分钟，就好像很厉害了的样子。其实想想高中的时候，一坐一晚上几个小时都能精力高度集中完成任务。只是随着智能手机和互联网的发展，我们经常被一些无关痛痒的消息打断，导致我们难以集中精力，注意力阀值降低。提高自己的注意力阀值，be focus，你最终发现番茄工作法什么的弱爆了。 下面介绍一些你需要知道的保持高效率的建议。（1）是每天学一点还是考前抱佛脚？看起来后者节约时间，实际上前者才是高效率。（2）你的笔记和课本组织得好吗？虽然我喜欢一次学习就搞定它，但是有时候我们还是需要复习，假如学习材料凌乱无序，肯定会浪费时间。材料越有组织，复习起来压力越小。（3）学习时注意力高度集中，还是左顾右盼、三心二意？我学习时从不听音乐、玩手机或看信息，我总是尽量找一个没有人的地方学习。 后记这本书虽然看起来很薄，但是介绍的方法和内容比较多。看的时候感觉很好很有道理值得应用，但实际操作起来容易遗忘和忽略一些部分，所以我建议要时不时地温习。 在书中后半部分有讲 “不要学习”，其实这就体现了翻译的局限性，“learn” 和 “study” 都翻译为 “学习”，而一个强调学习结果，一个强调你在 “学习”(看起来在学习)的过程。在 “不要学习” 这一部分中的 “学习” 指的是 “study”。 工具的产生极大地提高了人类的工作效率和生产力。而此书所介绍概念、方法，就是我们学习过程中可以利用的强大工具。 但是，工具不是一切，不能纠结于工具本身。最重要的还是我们要有「终身学习」的信念 (注意，我不是说观念)。 工具是好的，但不是一切都决定于工具。又想起来《蝙蝠侠五》中忍者大师教给韦恩的那句话：「Skill is nothing, will is everythin.」 学习是一辈子的事情。随着互联网的发展与普及，还有在线支付功能的完善，「知识变现」变得越来越容易。学点东西，开始更加明显地提高我们的生产力。这本书不光提供我们一些方法，也能激起我们学习的热情。 努力学习，追求进步。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用IAR写汇编]]></title>
    <url>%2F2016%2F07%2F25%2F%E7%94%A8IAR%E5%86%99%E6%B1%87%E7%BC%96%2F</url>
    <content type="text"><![CDATA[version：IAR7.5创建工程具体参见百度经验前四步。戳→这里。其中，在创建工程时，选择 asm 如图 然后界面变成这样： 删掉它自带的代码，改为下列代码： 12345678910111213141516171819202122232425262728MODULE ?cstartup ;; Forward declaration of sections. SECTION CSTACK:DATA:NOROOT(3) SECTION .intvec:CODE:NOROOT(2) ;EXTERN __iar_program_start PUBLIC __vector_table DATA __vector_table DCD sfe(CSTACK) DCD Reset_Handler ; Reset Handler ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;; ;; Default interrupt handlers. ;; THUMB PUBWEAK Reset_Handler SECTION .text:CODE:NOROOT:REORDER(2) Reset_Handler ;LDR R0, =__iar_program_start ;BX R0 ;在这里放置汇编语言测试代码 再建一个文件，main.c，并添加到工程中，参考之前的百度经验链接第六、七步。 在 main.c中写一个 main 函数。 12int mian()&#123;&#125; //内容随意，可空 修改配置对工程点右键，选择“Options”， 然后将各位置的配置修改为同下图： 然后就可以写汇编了~]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
</search>
