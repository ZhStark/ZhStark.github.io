<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小豪&#39;s blog</title>
  
  <subtitle>痛无止境 学无止境</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhstark.com/"/>
  <updated>2019-05-28T08:59:13.234Z</updated>
  <id>http://zhstark.com/</id>
  
  <author>
    <name>Hao Zhao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>线程间通信</title>
    <link href="http://zhstark.com/2019/05/28/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>http://zhstark.com/2019/05/28/线程间通信/</id>
    <published>2019-05-28T08:58:37.000Z</published>
    <updated>2019-05-28T08:59:13.234Z</updated>
    
    <content type="html"><![CDATA[<p>锁机制：包括互斥锁、条件变量、读写锁</p><ul><li>互斥锁提供了以排他方式防止数据结构被并发修改的方法。</li><li>读写锁允许多个线程同时读共享数据，而对写操作是互斥的。</li><li>条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li></ul><p>信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量<br>信号机制(Signal)：类似进程间的信号处理<br>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;锁机制：包括互斥锁、条件变量、读写锁&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;互斥锁提供了以排他方式防止数据结构被并发修改的方法。&lt;/li&gt;
&lt;li&gt;读写锁允许多个线程同时读共享数据，而对写操作是互斥的。&lt;/li&gt;
&lt;li&gt;条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条
      
    
    </summary>
    
      <category term="学习笔记" scheme="http://zhstark.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="操作系统" scheme="http://zhstark.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>进程间的通信</title>
    <link href="http://zhstark.com/2019/05/28/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/"/>
    <id>http://zhstark.com/2019/05/28/进程间的通信/</id>
    <published>2019-05-28T08:41:56.000Z</published>
    <updated>2019-05-28T08:51:53.468Z</updated>
    
    <content type="html"><![CDATA[<p>管道，FIFO，消息队列，信号，信号量，Socket，共享内存。</p><p>转载自<a href="https://www.jianshu.com/p/c1015f5ffa74" target="_blank" rel="external">简书</a>.</p><a id="more"></a><h2 id="进程间通信的概念"><a href="#进程间通信的概念" class="headerlink" title="进程间通信的概念"></a>进程间通信的概念</h2><p>每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）</p><p><img src="/images/DraggedImage.c63c225d88444d1d923ff7add8c104c5.tiff" alt=""></p><h2 id="进程间通信的7种方式"><a href="#进程间通信的7种方式" class="headerlink" title="进程间通信的7种方式"></a>进程间通信的7种方式</h2><h3 id="管道-匿名管道-pipe"><a href="#管道-匿名管道-pipe" class="headerlink" title="管道/匿名管道(pipe)"></a>管道/匿名管道(pipe)</h3><ul><li>管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。</li><li>只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程);</li><li>单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。</li><li>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。</li></ul><p><img src="/images/DraggedImage.6418f939495e489298d40332e49ad5ef.tiff" alt=""></p><p><strong>管道的实质：</strong></p><p>管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。</p><p>该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。</p><p>当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。</p><p><strong>管道的局限：</strong></p><p>管道的主要局限性正体现在它的特点上：</p><ul><li>只支持单向数据流；</li><li>只能用于具有亲缘关系的进程之间；</li><li>没有名字；</li><li>管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）；</li><li>管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等；</li></ul><h3 id="有名管道-FIFO"><a href="#有名管道-FIFO" class="headerlink" title="有名管道(FIFO)"></a>有名管道(FIFO)</h3><p>匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道(FIFO)。</p><p>有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，以有名管道的文件形式存在于文件系统中，这样，即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信，因此，通过有名管道不相关的进程也能交换数据。值的注意的是，有名管道严格遵循先进先出(first in first out),对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。有名管道的名字存在于文件系统中，内容存放在内存中。</p><blockquote><p><strong>匿名管道和有名管道总结：</strong><br>（1）管道是特殊类型的文件，在满足先入先出的原则条件下可以进行读写，但不能进行定位读写。<br>（2）匿名管道是单向的，只能在有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。<br>（3）无名管道阻塞问题：无名管道无需显示打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出。如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞，如果管道发现另一端断开，将自动退出。<br>（4）有名管道阻塞问题：有名管道在打开时需要确实对方的存在，否则将阻塞。即以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。</p></blockquote><h3 id="信号-Signal"><a href="#信号-Signal" class="headerlink" title="信号(Signal)"></a>信号(Signal)</h3><ul><li>信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。</li><li>如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。</li><li>如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。</li></ul><blockquote><p><strong>Linux系统中常用信号：</strong><br>（1）SIGHUP：用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。<br>（2）SIGINT：程序终止信号。程序运行过程中，按Ctrl+C键将产生该信号。<br>（3）SIGQUIT：程序退出信号。程序运行过程中，按Ctrl+\键将产生该信号。<br>（4）SIGBUS和SIGSEGV：进程访问非法地址。<br>（5）SIGFPE：运算中出现致命错误，如除零操作、数据溢出等。<br>（6）SIGKILL：用户终止进程执行信号。shell下执行kill -9发送该信号。<br>（7）SIGTERM：结束进程信号。shell下执行kill 进程pid发送该信号。<br>（8）SIGALRM：定时器信号。<br>（9）SIGCLD：子进程退出信号。如果其父进程没有忽略该信号也没有处理该信号，则子进程退出后将形成僵尸进程。</p></blockquote><p><strong>信号来源</strong></p><p>信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，，信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件主要有两个来源：</p><ul><li>硬件来源：用户按键输入Ctrl+C退出、硬件异常如无效的存储访问等。</li><li>软件终止：终止进程信号、其他进程调用kill函数、软件异常产生信号。</li></ul><p><strong>信号生命周期和处理流程</strong></p><ol><li>信号被某个进程产生，并设置此信号传递的对象（一般为对应进程的pid），然后传递给操作系统；</li><li>操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到该进程解除了对此信号的阻塞（如果对应进程已经退出，则丢弃此信号），如果对应进程没有阻塞，操作系统将传递此信号。</li><li>目的进程接收到此信号后，将根据当前进程对此信号设置的预处理方式，暂时终止当前代码的执行，保护上下文（主要包括临时寄存器数据，当前程序位置以及当前CPU的状态）、转而执行中断服务程序，执行完成后在回复到中断的位置。当然，对于抢占式内核，在中断返回时还将引发新的调度。</li></ol><h3 id="消息-Message-队列"><a href="#消息-Message-队列" class="headerlink" title="消息(Message)队列"></a>消息(Message)队列</h3><ul><li>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。</li><li>与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。</li><li>另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达。延伸阅读：消息队列C语言的实践</li></ul><blockquote><p><strong>消息队列特点总结：</strong><br>（1）消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识.<br>（2）消息队列允许一个或多个进程向它写入与读取消息.<br>（3）管道和消息队列的通信数据都是先进先出的原则。<br>（4）消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比FIFO更有优势。<br>（5）消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。<br>（6）目前主要有两种类型的消息队列：POSIX消息队列以及System V消息队列，系统V消息队列目前被大量使用。系统V消息队列是随内核持续的，只有在内核重起或者人工删除时，该消息队列才会被删除。</p></blockquote><h3 id="共享内存-share-memory"><a href="#共享内存-share-memory" class="headerlink" title="共享内存(share memory)"></a>共享内存(share memory)</h3><ul><li>使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。</li><li>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。</li><li>由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。</li></ul><h3 id="信号量-semaphore"><a href="#信号量-semaphore" class="headerlink" title="信号量(semaphore)"></a>信号量(semaphore)</h3><p>信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。</p><p>为了获得共享资源，进程需要执行下列操作：</p><ol><li>创建一个信号量：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。</li><li>等待一个信号量：该操作会测试这个信号量的值，如果小于0，就阻塞。也称为P操作。</li><li>挂出一个信号量：该操作将信号量的值加1，也称为V操作。</li></ol><p>为了正确地实现信号量，信号量值的测试及减1操作应当是原子操作。为此，信号量通常是在内核中实现的。Linux环境中，有三种类型：Posix（可移植性操作系统接口）有名信号量（使用Posix IPC名字标识）、Posix基于内存的信号量（存放在共享内存区中）、System V信号量（在内核中维护）。这三种信号量都可用于进程间或线程间的同步。</p><blockquote><p><strong>信号量与普通整型变量的区别：</strong><br>（1）信号量是非负整型变量，除了初始化之外，它只能通过两个标准原子操作：wait(semap) , signal(semap) ; 来进行访问；<br>（2）操作也被成为PV原语（P来源于荷兰语proberen”测试”，V来源于荷兰语verhogen”增加”，P表示通过的意思，V表示释放的意思），而普通整型变量则可以在任何语句块中被访问；</p><p><strong>信号量与互斥量之间的区别：</strong><br>（1）互斥量用于线程的互斥，信号量用于线程的同步。这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。<br>互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。<br>同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。<br>在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源<br>（2）互斥量值只能为0/1，信号量值可以为非负整数。<br>也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。<br>（3）互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。</p></blockquote><h3 id="套接字-socket"><a href="#套接字-socket" class="headerlink" title="套接字(socket)"></a>套接字(socket)</h3><p>套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。</p><p>套接字是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</p><p><strong>套接字特性</strong><br>套接字的特性由3个属性确定，它们分别是：域、端口号、协议类型。<br>（1）套接字的域<br>它指定套接字通信中使用的网络介质，最常见的套接字域有两种：<br>一是AF_INET，它指的是Internet网络。当客户使用套接字进行跨网络的连接时，它就需要用到服务器计算机的IP地址和端口来指定一台联网机器上的某个特定服务，所以在使用socket作为通信的终点，服务器应用程序必须在开始通信之前绑定一个端口，服务器在指定的端口等待客户的连接。<br>另一个域AF_UNIX，表示UNIX文件系统，它就是文件输入/输出，而它的地址就是文件名。<br>（2）套接字的端口号<br>每一个基于TCP/IP网络通讯的程序(进程)都被赋予了唯一的端口和端口号，端口是一个信息缓冲区，用于保留Socket中的输入/输出信息，端口号是一个16位无符号整数，范围是0-65535，以区别主机上的每一个程序（端口号就像房屋中的房间号），低于256的端口号保留给标准应用程序，比如pop3的端口号就是110，每一个套接字都组合进了IP地址、端口，这样形成的整体就可以区别每一个套接字。<br>（3）套接字协议类型<br>因特网提供三种通信机制，<br>一是流套接字，流套接字在域中通过TCP/IP连接实现，同时也是AF_UNIX中常用的套接字类型。流套接字提供的是一个有序、可靠、双向字节流的连接，因此发送的数据可以确保不会丢失、重复或乱序到达，而且它还有一定的出错后重新发送的机制。<br>二个是数据报套接字，它不需要建立连接和维持一个连接，它们在域中通常是通过UDP/IP协议实现的。它对可以发送的数据的长度有限制，数据报作为一个单独的网络消息被传输,它可能会丢失、复制或错乱到达，UDP不是一个可靠的协议，但是它的速度比较高，因为它并一需要总是要建立和维持一个连接。<br>三是原始套接字，原始套接字允许对较低层次的协议直接访问，比如IP、 ICMP协议，它常用于检验新的协议实现，或者访问现有服务中配置的新设备，因为RAW SOCKET可以自如地控制Windows下的多种协议，能够对网络底层的传输机制进行控制，所以可以应用原始套接字来操纵网络层和传输层应用。比如，我们可以通过RAW SOCKET来接收发向本机的ICMP、IGMP协议包，或者接收TCP/IP栈不能够处理的IP包，也可以用来发送一些自定包头或自定协议的IP包。网络监听技术很大程度上依赖于SOCKET_RAW。</p><p>原始套接字与标准套接字的区别在于：<br>原始套接字可以读写内核没有处理的IP数据包，而流套接字只能读取TCP协议的数据，数据报套接字只能读取UDP协议的数据。因此，如果要访问其他协议发送数据必须使用原始套接字。</p><p>套接字通信的建立</p><p><img src="/images/DraggedImage.287e48b5da3e4f17a3b87e308c37d3cd.tiff" alt="Socket通信基本流程"></p><p><strong> 服务器端</strong></p><ol><li>首先服务器应用程序用系统调用socket来创建一个套接字，它是系统分配给该服务器进程的类似文件描述符的资源，它不能与其他的进程共享。</li><li>然后，服务器进程会给套接字起个名字，我们使用系统调用bind来给套接字命名。然后服务器进程就开始等待客户连接到这个套接字。</li><li>接下来，系统调用listen来创建一个队列并将其用于存放来自客户的进入连接。</li><li>最后，服务器通过系统调用accept来接受客户的连接。它会创建一个与原有的命名套接不同的新套接字，这个套接字只用于与这个特定客户端进行通信，而命名套接字（即原先的套接字）则被保留下来继续处理来自其他客户的连接（建立客户端和服务端的用于通信的流，进行通信）。</li></ol><p><strong>客户端</strong></p><ol><li>客户应用程序首先调用socket来创建一个未命名的套接字，然后将服务器的命名套接字作为一个地址来调用connect与服务器建立连接。</li><li>一旦连接建立，我们就可以像使用底层的文件描述符那样用套接字来实现双向数据的通信（通过流进行数据传输）。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;管道，FIFO，消息队列，信号，信号量，Socket，共享内存。&lt;/p&gt;
&lt;p&gt;转载自&lt;a href=&quot;https://www.jianshu.com/p/c1015f5ffa74&quot;&gt;简书&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://zhstark.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="操作系统" scheme="http://zhstark.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>进程与线程的区别</title>
    <link href="http://zhstark.com/2019/05/28/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://zhstark.com/2019/05/28/进程与线程的区别/</id>
    <published>2019-05-28T08:40:34.000Z</published>
    <updated>2019-05-28T08:41:02.459Z</updated>
    
    <content type="html"><![CDATA[<p>一个任务就是一个进程（Process），在一个进程内部，要同时干多件事情，就需要同时运行多个“子任务”，这些“子任务”称为线程（Thread）。</p><a id="more"></a><p>进程和线程的主要区别在于他们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其他进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉。所以多进程的程序要比多线程的程序健壮，但在进程切换时，消耗资源较大，效率要差一些。</p><ul><li>进程是资源分配的最小单位，线程是程序执行的最小单位。</li><li>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。</li><li>线程是共享进程中的数据的，使用相同的地址空间，因此 CPU 切换一个线程的花费远比进程要小的多，同时创建一个线程的开销也比进程要小很多。</li><li>线程之间的通信更方便，同一进程下的线程共享全局变量，静态变量等数据，而进程之间的通信需要以 IPC（InterProcess Communication) 的方式进行。不过如何处理好同步与互斥是编写多线程程序的难点。</li><li>多进程程序更健壮。因为进程有自己独立的空间。</li></ul><p>一个进程至少有一个线程，多线程的执行方式和多进程是一样的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个任务就是一个进程（Process），在一个进程内部，要同时干多件事情，就需要同时运行多个“子任务”，这些“子任务”称为线程（Thread）。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://zhstark.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="操作系统" scheme="http://zhstark.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>进程与线程的简单解释</title>
    <link href="http://zhstark.com/2019/05/28/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AE%80%E5%8D%95%E8%A7%A3%E9%87%8A/"/>
    <id>http://zhstark.com/2019/05/28/进程与线程的简单解释/</id>
    <published>2019-05-28T03:06:50.000Z</published>
    <updated>2019-05-28T03:16:38.274Z</updated>
    
    <content type="html"><![CDATA[<p>转载自<em><a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="external">阮一峰的网络日志</a></em></p><a id="more"></a><p>进程（process）和线程（thread）是操作系统的基本概念，但是它们比较抽象，不容易掌握。</p><p>最近，我读到一篇材料，发现有一个很好的类比，可以把它们解释地清晰易懂。</p><p>1.</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201304/bg2013042401.jpg" alt=""></p><p>计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。</p><p>2.</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201304/bg2013042402.png" alt=""></p><p>假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。</p><p>3.</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201304/bg2013042403.jpg" alt=""></p><p>进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。</p><p>4.</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201304/bg2013042404.jpg" alt=""></p><p>一个车间里，可以有很多工人。他们协同完成一个任务。</p><p>5.</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201304/bg2013042405.jpg" alt=""></p><p>线程就好比车间里的工人。一个进程可以包括多个线程。</p><p>6.</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201304/bg2013042406.png" alt=""></p><p>车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。</p><p>7.</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201304/bg2013042407.jpg" alt=""></p><p>可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。</p><p>8.</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201304/bg2013042408.jpg" alt=""></p><p>一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫”互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。</p><p>9.</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201304/bg2013042409.jpg" alt=""></p><p>还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。</p><p>10.</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201304/bg2013042410.jpg" alt=""></p><p>这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做”信号量”（Semaphore），用来保证多个线程不会互相冲突。</p><p>不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。</p><p>11.</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201304/bg2013042411.png" alt=""></p><p>操作系统的设计，因此可以归结为三点：</p><p>（1）以多进程形式，允许多个任务同时运行；</p><p>（2）以多线程形式，允许单个任务分成不同的部分运行；</p><p>（3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自&lt;em&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html&quot;&gt;阮一峰的网络日志&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://zhstark.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="操作系统" scheme="http://zhstark.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>关于网络的一些基础知识</title>
    <link href="http://zhstark.com/2019/05/28/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://zhstark.com/2019/05/28/关于网络的一些基础知识/</id>
    <published>2019-05-28T02:48:20.000Z</published>
    <updated>2019-05-28T03:50:11.875Z</updated>
    
    <content type="html"><![CDATA[<p>包括网络模型，TCP 的三次握手四次挥手，流量控制、拥塞控制以及 HTTP 的一些基础知识点。</p><a id="more"></a><h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><p><img src="/images/网络.png" alt=""></p><ul><li>OSI 七层模型。自下向上：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</li><li>TCPIP 四层模型：网络接口层，网际层，传输层，应用层</li></ul><h2 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP UDP"></a>TCP UDP</h2><p>所谓的建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="/images/DraggedImage.jpg" alt=""></p><p>A 先说“我不玩了”，进入 FIN_WAIT_1状态，<br>B 接收，发送“知道了”，进入 CLOSE_WAIT 状态<br>A 接收，进入 FIN_WAIT_2状态（等待超时 if B 跑路）<br>B 发送“我不玩了”<br>A 接收，发送回应（ACK），结束 FIN_WAIT_2状态，进入 TIME_WAIT.</p><p>TIME_WAIT 为两个 MSL（最大报文存活时长）</p><p><strong>为什么两个最大报文存活时长</strong></p><ol><li>确保最后一个确认报文段能够到达。如果 B 没有收到 A 发来的确认报文段，那么久会重新发送连接释放请求报文段，A 等待一段时间就是为了处理这种情况的发生。</li><li>可能存在“已失效的连接请求报文段”，为了防止这种报文段出现在本次链接之外，需要等待一段时间，防止串话。</li></ol><p><img src="/images/DraggedImage.eff5d057f282408e8046d1cfc197adde.png" alt=""></p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="https://static001.geekbang.org/resource/image/66/a2/666d7d20aa907d8317af3770411f5aa2.jpg" alt=""></p><p>一开始，客户端和服务端都处于 close 状态，先是服务端主动监听某个端口，处于 <em>Listen</em> 状态，然后客户端主动发起建立<em>SYN</em>，处于<em>SYN-SEND 状态</em>，服务端收到发起的连接，返回<em>SYN</em>，并且 ACK 客户端的 SYN，处于<em>SYN-RCVD</em>状态，客户端收到服务端的 SYN 和 ACK之后，发送 ACK 的 ACK，然后处于<em>ESTABLISHED</em>状态。服务端收到 ACK 的 ACK 之后，处于<em>ESTABLISHED</em>状态。</p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>为了保障顺序性，每一个包都有一个 ID。为了保证不丢包，对于发送的包都要进行应答。但是这个应答也不是一个一个来的，而是会应答某个之前的 ID，表示都收到了，这样的模式称为<strong>累计确认</strong>或者<strong>累计应答</strong>（cumulative acknowledgment）。</p><p>TCP 将所有的包按照 ID 的排列划分：</p><ol><li>第一部分，发送了并且已经确认的</li><li>第二部分，发送了并且尚未确认的</li><li>第三部分，没有发送，但是已经等待发送的</li><li>第四部分，没有发送，而且暂时也不会发送</li></ol><p>在 TCP 里，接收端会给发送端报一个窗口的大小，叫做<em>Advertised window</em>。这个窗口的大小应该等于上面两个的第二部分加上第三部分。在对包的确认中，同时会携带一个窗口的大小。<strong>滑动窗口（rwnd）</strong>是怕发送方把接收方缓存塞满。</p><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>滑动窗口是怕发送方把接收方缓存塞满，而<strong>拥塞窗口（cwnd）</strong>是怕把网络塞满。</p><p>TCP 的拥塞控制主要来避免两种现象：<strong>包丢失</strong>和<strong>超时重传</strong></p><h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4><p>一条 TCP 连接开始，cwnd 设置为一个报文段，一次只能发送一个；当收到这一个确认的时候，cwnd+1，于是一次能够发送两个；当这两个的确认到来的时候，每个确认 cwnd+1，两个确认 cwnd+2，于是一次能够发送四个；当这四个确认到来的时候，每个确认 cwnd+1，四个确认 cwnd+4，于是一次能够发送八个，所以是指数型增长。</p><p>涨到什么时候是个头呢，有一个值 ssthresh（slow start threshold） 为 65535 个字节，当超过这个值的时候，就不那么快了。</p><p>这时，每收到一个确认后，cwnd 增加 1/cwnd，我们接着上面的过程，一次发送八个，当八个确认到来的时候，每个确认增加 1/8，八个确认一共 cwnd+1，于是一次能够发送九个，变成了线性增长。</p><p>但只要增长就会越来越多。直到有一天，水满则溢，出现了拥塞，这时候一般就会一下子降低倒水的速度。</p><p>拥塞的一种表现形式是丢包，需要超时重传。这个时候，将 ssthresh 设为 cwnd/2，将 cwnd 设为 1，重新开始慢启动。但这种方式太激进了，将一个高速的传输速度一下子停了下来，会造成网络卡顿。</p><h4 id="快速重传算法"><a href="#快速重传算法" class="headerlink" title="快速重传算法"></a>快速重传算法</h4><p>当接收端发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速的重传，不必等待超时再重传。这时 cwnd=cwnd/2，ssthresh=cwnd，当三个包返回的时候，cwnd=ssthresh+3。</p><p>后来还有<strong>BBR 拥塞算法</strong>，它企图找到一个平衡点，就是通过不断的加快发送速度，将管道填满，但是不填满中间设备的缓存，因为这样延时会增加。</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="What-will-happen-when-you-input-URL-into-Browser"><a href="#What-will-happen-when-you-input-URL-into-Browser" class="headerlink" title="What will happen when you input URL into Browser."></a>What will happen when you input URL into Browser.</h3><ol><li>Use the URL to get the IP address by submit it to ISP and DMS turn it into IP address</li><li>New HTTP request is sent including your IP address. the time you sent it and the page you asking for</li><li>The server get the request. go the database to get the data, compile them into a long html file and send it back to your IP as HTTP response</li><li>The browser render the page.</li></ol><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li>GET。GET 就是去服务器获取一些资源。</li><li>POST。它需要主动告诉服务端一些信息。要告诉服务端什么呢？一般会放到正文里。（常见格式 JSON）</li><li>PUT。向指定资源位置上传最新内容。</li><li>DELETE。用来删除资源</li></ul><h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><ul><li>IP 地址是一个网卡在网络世界中的通讯地址，相当于现实世界中的门牌号</li><li>无类型域间选路 CIDR （Classless Inter-Domain Routing）xx.xxx.xxx.xx/24 32位中，前24位是网络号</li><li>将子网掩码和 IP 地址按位运算AND，就得到网络号</li><li>IP 是地址，有定位功能， MAC 是身份证，无定位功能</li><li>CIDR 可以判断是不是本地</li></ul><p>DHCP 动态主机配置协议</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;包括网络模型，TCP 的三次握手四次挥手，流量控制、拥塞控制以及 HTTP 的一些基础知识点。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://zhstark.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="网络" scheme="http://zhstark.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>关于数据库的一些基础知识</title>
    <link href="http://zhstark.com/2019/05/27/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://zhstark.com/2019/05/27/关于数据库的一些基础知识/</id>
    <published>2019-05-27T13:07:29.000Z</published>
    <updated>2019-05-27T13:11:43.570Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些关于数据库的常考知识点，包括三大范式，锁，MySQL 的 B+树索引</p><a id="more"></a><h2 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h2><h3 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h3><p>减少冗余，将具有紧密逻辑联系的属性放到同一个关系中。</p><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p>描述一个关系中属性之间的联系。设 A 和 B 均为关系 R 的属性，若 A 的每个值都和 B 中的一个唯一的值相对应，则称 B 函数依赖与 A，记为 A→B</p><h3 id="完全函数依赖"><a href="#完全函数依赖" class="headerlink" title="完全函数依赖"></a>完全函数依赖</h3><p>假设 A 和 B 是某一关系的属性，若 B 函数依赖于 A，但不函数依赖于 A 的任意一个真子集，则称 B 完全函数依赖与 A。</p><p>对于函数依赖A→B，如果去掉 A 的任意一个属性使得该依赖不成立，那么 B 完全函数依赖于 A。</p><h3 id="非范式"><a href="#非范式" class="headerlink" title="非范式"></a>非范式</h3><p>包含一个或多个重复的表</p><h3 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h3><p>数据库表中的所有字段值都是不可分解的原子值</p><h3 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h3><p>满足第一范式的要求并且每个非主关键字属性都完全函数依赖于主关键字的关系。<br>将第一范式规范化为第二范式是为了消除部分依赖。</p><h3 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h3><p>满足第一第二范式并且所有非主关键属性都不传递依赖于主关键字的关系。<br>将2NF 规范化为3NF 需要消除传递依赖。如果存在传递依赖，就将传递依赖的属性移到一个新的关系中，并将这些属性的决定方也复制到该关系中。</p><h2 id="ACID-事务的4个基本性质"><a href="#ACID-事务的4个基本性质" class="headerlink" title="ACID 事务的4个基本性质"></a>ACID 事务的4个基本性质</h2><ul><li>A, atomicity 原子性：要么全部执行，要么全部不执行</li><li>C, Consistency 一致性：事务必须将数据库从一种一致的状态转换到另一种一致的状态。</li><li>I, Isolation 隔离性：事务的执行是相互独立的，未完成的事务的中间结果对其他事务是不可见的。</li><li>D, Durability 持久性：成功提交的事务的结果要永久的记录在数据库中，不能因为以后的故障而丢失。</li></ul><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁/悲观锁"></a>乐观锁/悲观锁</h3><p>乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。</p><p>悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。</p><p>乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。</p><p>从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁（Deadlock）就是指两个或两个以上的进程在执行的过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去，此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p><h4 id="四个充要条件"><a href="#四个充要条件" class="headerlink" title="四个充要条件"></a>四个充要条件</h4><ol><li><p>互斥条件： 指进程对所分配的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直到占有资源的进程用完后释放资源。</p></li><li><p>占有且等待条件： 指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程阻塞，但它不会释放自己已经占有的资源。</p></li><li><p>非抢占条件： 指进程已经获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</p></li><li><p>循环等待条件 存在一个封闭的进程链，使得每个资源至少占有此链中下一个进程所需要的一个资源。</p></li></ol><h2 id="MySQL-数据库索引：B-树"><a href="#MySQL-数据库索引：B-树" class="headerlink" title="MySQL 数据库索引：B+树"></a>MySQL 数据库索引：B+树</h2><p>我们希望通过索引，查询数据的效率尽可能的高；在存储空间方面，我们希望索引不要消耗太多的内存空间。</p><p>大部分数据结构都不支持按区间查找。</p><p>B+树由二叉搜索树演化而来。为了让二叉搜索树支持按照区间来查找数据，我们将树中的节点并不存储数据本身，而是只作为索引。除此之外，我们把每个叶子节点穿在一条链表上，链表中的数据是从小到大有序的。改造之后，如果我们要求某个区间的数据，我们只需要那区间的初始值，在树中进行查找，当找到某个叶子节点之后，再顺着链表往后遍历，直到链表中的节点数据值大于区间的终止值为止。</p><p>由于数据库中数据量太大，不可能存入内存中，所以我们只能将索引存储在硬盘中，每个节点的读取（或访问）都对应一次磁盘的 IO 操作。那么树的高度就等于每次查询数据时磁盘 IO 操作的次数。</p><p>而硬盘的读取速度太慢，所以需要尽可能减少磁盘 IO 操作，也就是降低树的高度。</p><p>那么我们将索引构建成 m 叉树就可以减小树的高度。但 m 并不是越大越好。</p><p>不管是内存中的数据，还是磁盘中的数据，操作系统都是按页来读取的，一次会读取一页的数据。如果要读取的数据量超过一页的大小，就会触发多次 IO 操作。所以，我们在选择 m 大小的时候，要尽量让每个节点的大小等于一个页的大小。读取一个节点，只一次磁盘 IO 操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一些关于数据库的常考知识点，包括三大范式，锁，MySQL 的 B+树索引&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://zhstark.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="http://zhstark.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>重学c++5 函数</title>
    <link href="http://zhstark.com/2019/04/25/%E9%87%8D%E5%AD%A6cpp%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/"/>
    <id>http://zhstark.com/2019/04/25/重学cpp函数的参数/</id>
    <published>2019-04-25T15:15:18.000Z</published>
    <updated>2019-05-01T13:31:48.301Z</updated>
    
    <content type="html"><![CDATA[<p>关于：形参于实参, 声明, 分离式编译, 数组参数, main 函数参数, 可变参数，默认实参，函数指针</p><a id="more"></a><h3 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h3><p>函数定义时参数列表里的是形参（parameter），使用函数时，放进圆括号里的是实参（argument）。实参是形参的初始值。</p><h3 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h3><p>因为函数的声明不包含函数体，所以也就无须形参的名字。所以在函数的生命中经常省略形参的名字。</p><p>函数声明也称为函数原型</p><h3 id="分离式编译"><a href="#分离式编译" class="headerlink" title="分离式编译"></a>分离式编译</h3><p>分离式编译允许我们吧程序分割到几个文件中去，每个文件独立编译。</p><p>如果我们修改了其中一个源文件，那么只需要重新编译那个改动了的文件。这一过程通常会产生的一个后缀名是<code>.obj</code> 或者 <code>.o</code>的文件。后缀名的含义是该文件包含对象代码 (object code)。接下来编译器负责吧对象文件链接到一起形成可执行文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ CC -c main.cc <span class="meta"># generates main.o</span></div><div class="line">$ CC -c fact.cc <span class="meta"># generates fact.o</span></div><div class="line">$ CC main.o fact.o -o main <span class="meta"># generate main or main.exe</span></div></pre></td></tr></table></figure><h3 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a>数组形参</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>*)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[])</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[<span class="number">10</span>])</span></span>;</div></pre></td></tr></table></figure><h4 id="数组引用形参"><a href="#数组引用形参" class="headerlink" title="数组引用形参"></a>数组引用形参</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void print(int (&amp;arr)[10])&#123;</div><div class="line">.....</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>只能将函数作用于大小为 10 的数组。</p><h4 id="传递多维数组"><a href="#传递多维数组" class="headerlink" title="传递多维数组"></a>传递多维数组</h4><p>首元素本身就是一个数组， 指针就是一个指向数组的指针。数组的第二维的大小都是数组类型的一部分，不能省略。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">void print(int maxtrix[][10], int rowSize)&#123;&#125;</div><div class="line">void print(int (*matrix)[10], int rowSize)&#123;...&#125; //matrix 为指向含有 10 个整数的数组的指针</div><div class="line"></div><div class="line">int *matrix[10]; //10个指针构成的数组</div><div class="line">int (*matrix)[10];//指向含有 10 个整数的数组的指针</div></pre></td></tr></table></figure><h3 id="main-函数的参数"><a href="#main-函数的参数" class="headerlink" title="main 函数的参数"></a>main 函数的参数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;...&#125;</div><div class="line"><span class="comment">//argv 是一个数组，他的元素是指向 C 风格字符串的指针；argc 表示数组中字符串的数量。</span></div><div class="line"><span class="comment">//因为第二个形参是数组，所以也可写成：</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;...&#125;</div><div class="line"><span class="comment">//argv 指向 char*</span></div></pre></td></tr></table></figure><p>假设 main 函数位于可执行文件 a 里，我们可以向程序传递下面的选项</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a -d -o ofile data0</div></pre></td></tr></table></figure><p>此时，argc=5，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">argv[<span class="number">0</span>]=<span class="string">"a"</span>;</div><div class="line">argv[<span class="number">1</span>]=<span class="string">"-d"</span>;</div><div class="line">argv[<span class="number">2</span>]=<span class="string">"-o"</span>;</div><div class="line">argv[<span class="number">3</span>]=<span class="string">"ofile"</span>;</div><div class="line">argv[<span class="number">4</span>]=<span class="string">"data0"</span>;</div><div class="line">argv[<span class="number">5</span>]=<span class="string">'\0'</span>;</div></pre></td></tr></table></figure><p>所以用 argv 的实参时要从 <code>argv[1]</code>开始。</p><h3 id="可变形参"><a href="#可变形参" class="headerlink" title="可变形参"></a>可变形参</h3><p>对于实参类型相同的，使用<code>initializer_list</code>标准库类型，需要<code>include &lt;initializer_list&gt;</code>。对于实参类型不同的，使用<strong>可变参数模板</strong>。</p><h3 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a=<span class="number">1</span>, <span class="keyword">int</span> b=<span class="number">2</span>)</span></span>&#123;...&#125;</div></pre></td></tr></table></figure><p>一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。</p><p>函数调用时实参按其位置解析，要想覆盖后面的默认值必须为前面参数提供实参。</p><p>当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面。</p><h5 id="默认实参声明"><a href="#默认实参声明" class="headerlink" title="默认实参声明"></a>默认实参声明</h5><p>在给定作用域中一个形参只能被赋予一次默认实参，即函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。</p><h5 id="默认实参初始值"><a href="#默认实参初始值" class="headerlink" title="默认实参初始值"></a>默认实参初始值</h5><p>局部标量不能作为默认实参</p><h3 id="内联函数-inline"><a href="#内联函数-inline" class="headerlink" title="内联函数 inline"></a>内联函数 inline</h3><p>调用函数会包含一系列开销，将函数指定为内联函数，则将它在每个调用点上“内联地”展开。从而消除了调用函数的开销。</p><p>在函数的返回类型前面加上关键字<em>inline</em>，就可以将它声明为内联函数了。</p><p>一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。内联说明只是向编译器发送一个请求，编译器可以选择忽略这个请求。</p><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>函数指针指向某种特定类型，函数的类型由他的返回类型和形参类型共同决定，与函数名无关。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</div></pre></td></tr></table></figure><p>该函数的类型是<code>bool(const string&amp;, const string&amp;)</code>。 要想声明一个可以指向该函数的指针，只需要用指针替换函数名即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> (*pf)(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;);</div></pre></td></tr></table></figure><p><code>pf</code>指向一个函数。如果对<code>*pf</code>两端不加括号，那么<code>pf</code>是一个返回值为 bool 指针的函数。</p><p>当我们吧函数名作为一个值使用时，该函数自动转换为指针。</p><h5 id="函数指针形参"><a href="#函数指针形参" class="headerlink" title="函数指针形参"></a>函数指针形参</h5><p>直接使用函数指针类型显得冗长而烦琐，类型别名和<code>decltype</code>可以简化函数指针的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Func and Func2 have function type</span></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">bool</span> <span class="title">Func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> Func2</span>;</div><div class="line"></div><div class="line"><span class="comment">//FuncP and Funcp2 have pointer to function type</span></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span><span class="params">(*FuncP)</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> *FuncP2</span>;</div></pre></td></tr></table></figure><p><strong><code>decltype</code>返回函数类型，此时不会将函数类型自动转换成指针类型。</strong></p><h5 id="返回指向函数的指针"><a href="#返回指向函数的指针" class="headerlink" title="返回指向函数的指针"></a>返回指向函数的指针</h5><p>我们必须吧返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。要想声明一个返回函数指针的函数，最简单的办法就是使用类型别名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> F=<span class="keyword">int</span>(<span class="keyword">int</span>*, <span class="keyword">int</span>);<span class="comment">//F 是函数类型</span></div><div class="line"><span class="keyword">using</span> PF=<span class="keyword">int</span>(*)(<span class="keyword">int</span>*, <span class="keyword">int</span>);<span class="comment">// PF 是指针类型</span></div></pre></td></tr></table></figure><p>和函数类型的形参不一会，返回类型不会自动地转换成指针。我们必须显式地将返回类型指定为指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</div><div class="line"><span class="function">F* <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</div></pre></td></tr></table></figure><p><strong>如果我们明确知道返回的函数是哪一个，就能使用 decltype 简化书写函数指针返回类型的过程</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span>::<span class="function">size_type <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</div><div class="line"><span class="keyword">decltype</span>(f)* getFcn(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于：形参于实参, 声明, 分离式编译, 数组参数, main 函数参数, 可变参数，默认实参，函数指针&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://zhstark.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://zhstark.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>重学cpp4 数组</title>
    <link href="http://zhstark.com/2019/03/25/%E9%87%8D%E5%AD%A6cpp-array/"/>
    <id>http://zhstark.com/2019/03/25/重学cpp-array/</id>
    <published>2019-03-25T13:00:32.000Z</published>
    <updated>2019-04-26T04:30:57.319Z</updated>
    
    <content type="html"><![CDATA[<p>关于数组的声明，指针与二维数组</p><a id="more"></a><h3 id="复杂的数组声明"><a href="#复杂的数组声明" class="headerlink" title="复杂的数组声明"></a>复杂的数组声明</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *ptrs[<span class="number">10</span>];<span class="comment">//ptrs 是一个含有10个 整型指针 的数组</span></div><div class="line"><span class="keyword">int</span> &amp;refs[<span class="number">10</span>]= arr;<span class="comment">// Wrong，不存在引用的数组</span></div><div class="line"><span class="keyword">int</span> (*P)[<span class="number">10</span>]=&amp;arr;<span class="comment">//P是一个指针，指向一个含有10个整数的数组</span></div><div class="line"><span class="keyword">int</span> (&amp;arrRef)[<span class="number">10</span>]=arr;<span class="comment">//arrRef 引用一个含有10个整数的数组</span></div><div class="line"><span class="keyword">int</span> * (&amp;arr)[<span class="number">10</span>]=ptrs;<span class="comment">//arr 是数组的引用，该数组含有10个指针</span></div></pre></td></tr></table></figure><h3 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> nums[]=&#123;<span class="string">"onr"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>&#125;;</div><div class="line"><span class="built_in">string</span> *p=nums;<span class="comment">// string *p=&amp;nums[0];</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">auto</span> <span class="title">p2</span><span class="params">(nums)</span></span>;<span class="comment">//p2为指向字符串的指针，指向 nums 的第一个元素</span></div><div class="line"><span class="function"><span class="keyword">auto</span> <span class="title">p2</span><span class="params">(&amp;nums[<span class="number">0</span>])</span></span>;</div><div class="line">*p2=<span class="string">"sfa"</span>;</div></pre></td></tr></table></figure><p>当用<code>decltype</code>时，跟上面又不一样了，不再返回指针，而是返回数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> ia[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</div><div class="line"></div><div class="line"><span class="keyword">decltype</span>(ia) ia2=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;<span class="comment">//decltype 返回的类型是由10个整数构成的数组</span></div></pre></td></tr></table></figure><h3 id="把指针当迭代器"><a href="#把指针当迭代器" class="headerlink" title="把指针当迭代器"></a>把指针当迭代器</h3><p>重点在于找到终止点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *e=&amp;arr[<span class="number">10</span>];<span class="comment">//指向 arr 最后一个元素的下一个位置。</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> *b=arr; b!=e; ++b)&#123;&#125;</div><div class="line"><span class="comment">// or</span></div><div class="line"><span class="keyword">int</span> *e=end(arr);<span class="comment">//#include &lt;iterator&gt;</span></div><div class="line"><span class="keyword">int</span> *b=begin(arr);<span class="comment">//This is better</span></div></pre></td></tr></table></figure><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>]=&#123;</div><div class="line">&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</div><div class="line">&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,</div><div class="line">&#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">1</span>&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;<span class="comment">//same</span></div></pre></td></tr></table></figure><h3 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h3><p><strong>数组不能被拷贝</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于数组的声明，指针与二维数组&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://zhstark.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://zhstark.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>重学c++3 decltype &amp; string</title>
    <link href="http://zhstark.com/2019/03/24/%E9%87%8D%E5%AD%A6cpp-decltype-and-string/"/>
    <id>http://zhstark.com/2019/03/24/重学cpp-decltype-and-string/</id>
    <published>2019-03-24T12:40:32.000Z</published>
    <updated>2019-04-26T04:30:37.878Z</updated>
    
    <content type="html"><![CDATA[<p>关于<code>decltype</code> 和 string 的一些东西。 decltype返回方程的返回类型。</p><a id="more"></a><h2 id="三-decltype"><a href="#三-decltype" class="headerlink" title="三 decltype"></a>三 decltype</h2><p>decltype的作用是选择并返回操作数的数据类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">decltype</span>(f()) s=x;<span class="comment">//s 的类型为函数 f 的返回值类型</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> c1=<span class="number">0</span>, &amp;c2=c1;</div><div class="line"><span class="keyword">decltype</span>(c1) x=<span class="number">0</span>;<span class="comment">//const int x</span></div><div class="line"><span class="keyword">decltype</span>(c2) y=x;<span class="comment">//const int &amp;y=x;</span></div></pre></td></tr></table></figure><p>如果 decltype 的表达式加上了一对括号，这样的 decltype 会得到一个引用类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</div><div class="line"><span class="keyword">decltype</span>((i)) d=i;<span class="comment">//d是一个 int&amp; 引用变量</span></div></pre></td></tr></table></figure><h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><h3 id="using-声明"><a href="#using-声明" class="headerlink" title="using 声明"></a>using 声明</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>::name;</div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</div></pre></td></tr></table></figure><p>头文件的代码一般不能使用 using 声明，因为头文件的内容会拷贝到所有引用他的文件中去。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="getline-函数"><a href="#getline-函数" class="headerlink" title="getline 函数"></a>getline 函数</h4><p><strong>在最终得到的字符串中保留输入时的空白符</strong><br><code>getline(ins, s)</code> 第一个参数是输入流，第二个参数是 string。函数从输入流中读入内容，直到遇到换行符为止。</p><p><strong>输入运算符作为判断条件</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;value)</div></pre></td></tr></table></figure></p><p><code>cin&gt;&gt;value</code> 返回 cin，一个<code>istream</code> 对象。当使用<code>istream</code>对象作为判断条件时，效果是检测流的状态。当遇到文件结束符或一个无效的输入时，判断为假。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;<span class="built_in">string</span> line;</div><div class="line"><span class="keyword">while</span>(getline(<span class="built_in">cin</span>, line))</div><div class="line"><span class="built_in">cout</span>&lt;&lt;line&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="string-相加"><a href="#string-相加" class="headerlink" title="string 相加"></a>string 相加</h4><p>当把 string 对象和字符字面值及字符串字面值混在一条语句中使用，必须确保每个加法运算符的两侧的运算对象至少有一个是 string<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> s4=s1+<span class="string">","</span>;<span class="comment">//right</span></div><div class="line"><span class="built_in">string</span> s5= <span class="string">"hello"</span>+<span class="string">","</span>; <span class="comment">//wrong</span></div><div class="line"><span class="built_in">string</span> s6=s1+<span class="string">","</span>+<span class="string">"hjello"</span>;<span class="comment">//right</span></div><div class="line"><span class="built_in">string</span> s7=<span class="string">"hello"</span>+<span class="string">","</span>+s1;<span class="comment">//wrong</span></div></pre></td></tr></table></figure></p><h4 id="处理字符"><a href="#处理字符" class="headerlink" title="处理字符"></a>处理字符</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></div><div class="line"><span class="built_in">isalnum</span>(c)</div><div class="line"><span class="built_in">isalpha</span>(c)</div><div class="line"><span class="built_in">isdigit</span>(c)</div><div class="line"><span class="built_in">islower</span>(c)</div><div class="line"><span class="built_in">isupper</span>(c)</div><div class="line"><span class="built_in">isspace</span>(c)</div><div class="line"><span class="built_in">tolower</span>(c)</div><div class="line"><span class="built_in">toupper</span>(c)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于&lt;code&gt;decltype&lt;/code&gt; 和 string 的一些东西。 decltype返回方程的返回类型。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://zhstark.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://zhstark.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>重学C++2  const</title>
    <link href="http://zhstark.com/2019/03/16/%E9%87%8D%E5%AD%A6cpp-const/"/>
    <id>http://zhstark.com/2019/03/16/重学cpp-const/</id>
    <published>2019-03-16T13:27:59.000Z</published>
    <updated>2019-04-26T04:27:00.944Z</updated>
    
    <content type="html"><![CDATA[<p>指向常量的指针，常量指针，指向常量的常量指针 = =！</p><a id="more"></a><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>默认状态下，<code>const</code>对象只在文件内有效。如果只在一个文件中定义 <code>const</code>，而在其他多个文件中声明并使用它，那么对 <code>const</code> 变量不管是声明还是定义都添加<code>extern</code> 关键字。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//file.cc中定义并初始化</span></div><div class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> a=<span class="number">1</span>;</div><div class="line"><span class="comment">//file.h 中声明</span></div><div class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> a;<span class="comment">//这俩 a 是同一个</span></div></pre></td></tr></table></figure></p><p><strong>对常量的引用（reference to const）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> c1=<span class="number">1</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1=c1;</div><div class="line"><span class="keyword">int</span> &amp;r2=c1;<span class="comment">//错误，非常量引用不能指向常量</span></div></pre></td></tr></table></figure><p><strong>指向常量的指针</strong> 要想放常量的地址，只能用指向常量的指针。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi=<span class="number">3.14</span>;</div><div class="line"><span class="keyword">double</span> *p1=&amp;pi;<span class="comment">// WRONG!</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">double</span> *p2= &amp;pi;<span class="comment">//Right</span></div></pre></td></tr></table></figure></p><h2 id="const-指针"><a href="#const-指针" class="headerlink" title="const 指针"></a>const 指针</h2><p>允许吧指针本身定义为常量，<strong>常量指针</strong>（const pointer）必须初始化。把*放在 const 之前，来说明指针是一个常量，此时不变的是指针本身，而不是指针指向的值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p=&amp;num;<span class="comment">// const pointer，p 不能改，（*p)可以改</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi=<span class="number">3.14</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> p2=&amp;pi;</div></pre></td></tr></table></figure></p><blockquote><p>弄清声明含义可以从右向左读。</p></blockquote><h3 id="顶层-const-amp-底层-const"><a href="#顶层-const-amp-底层-const" class="headerlink" title="顶层 const &amp; 底层 const"></a>顶层 const &amp; 底层 const</h3><p>顶层 const 可以表示任意的对象是常量（如表明指针本身是一个常量），而底层 const 表示指针所指的对象使一个常量。</p><h2 id="常量表达式-const-expression"><a href="#常量表达式-const-expression" class="headerlink" title="常量表达式 const expression"></a>常量表达式 const expression</h2><p>常量表达式是指值不变并且在编译过程就能得到计算结果的表达式。</p><p>C++11允许将变量声明为 <code>constexpr</code>类型以便由编译器来验证变量的值是否是一个常量表达式。声明为 constexpr 的变量一定是一个常量，而且必须用常量表达式初始化。（还有 constepr 函数，在编译时计算出结果）。</p><p><strong>在 constexpr 声明中如果定义了一个指针，限定符 constexpr 仅对指针有效，与指针所指的对象无关</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p=<span class="literal">nullptr</span>;<span class="comment">//一个指向整型常量的指针</span></div><div class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *q=<span class="literal">nullptr</span>;<span class="comment">//一个指向整数的常量指针</span></div><div class="line"></div><div class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> i=<span class="number">0</span>;</div><div class="line"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">int</span> *pp=&amp;i;<span class="comment">//指向常量的常量指针</span></div></pre></td></tr></table></figure><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p><strong>类型别名</strong>是一个名字，是某种类型的同义词。有两种方法。</p><p>1.typedef<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages; <span class="comment">//wages 就是 double</span></div><div class="line"><span class="keyword">typedef</span> wages base, *p; <span class="comment">// base 就是 double，p 是 double *的同义词</span></div></pre></td></tr></table></figure></p><p>2.别名声明<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> SI=<span class="keyword">int</span>;</div></pre></td></tr></table></figure></p><p><strong>坑</strong>：如果某个类型别名指代的是<strong>复合类型</strong>或<strong>常量</strong>，结果跟你想的可能不太一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pstring;<span class="comment">//pstring 是 char * 别名</span></div><div class="line"><span class="keyword">const</span> pstring cs=<span class="number">0</span>；<span class="comment">// cs 是指向 char 的 “常量指针”！不是指向常量字符的指针</span></div><div class="line"><span class="keyword">const</span> pstring *p;<span class="comment">//p是一个指针，他的对象是指向 char 的常量指针</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;指向常量的指针，常量指针，指向常量的常量指针 = =！&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://zhstark.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://zhstark.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>重学 C++</title>
    <link href="http://zhstark.com/2019/03/09/%E9%87%8D%E5%AD%A6%20cpp/"/>
    <id>http://zhstark.com/2019/03/09/重学 cpp/</id>
    <published>2019-03-09T09:38:52.000Z</published>
    <updated>2019-04-26T03:15:57.085Z</updated>
    
    <content type="html"><![CDATA[<p><em>之前学的不够扎实，更加系统、贴近底层的学一遍。非新手笔记，都是比较基础的东西，但没有最最基础的东西</em></p><a id="more"></a><h2 id="零"><a href="#零" class="headerlink" title="零"></a>零</h2><p><code>main</code> 函数的返回类型必须是<code>int</code>，返回 0 表明成功。</p><ul><li>curly brace 花括号</li><li>block of statements 语句块</li><li><p>assignment 赋值</p></li><li><p>windows: <code>.\</code>表示该文件在当前目录中，Unix: <code>./</code> 表示可执行文件在当前目录中。 </p></li><li><p>stream：流，一个流就是一个字符序列。随着时间的推移，字符是顺序生成或消耗的。</p></li><li>cin</li><li>cout</li><li>cerr</li><li>clog</li><li><code>&lt;&lt;</code> 输出运算符，返回其左侧的运算对象</li><li><code>endl</code>是一个被称为操作符(manipulator)的特殊值，写入<code>endl</code>的效果是结束当前行，并将于设备关联的 buffer 中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流。</li><li><code>::</code> 作用域运算符</li><li><code>&gt;&gt;</code> 输入运算符，返回左侧运算对象</li></ul><p>当用一个<code>istream</code> 对象作为判断条件时，其效果是检测stream 的状态。当流未遇到错误，即为true。但遇到文件结束符（ctrl+D in Mac）或遇到无效输入，状态变为无效，条件为 false。</p><p><strong>文件重定向</strong> 将标准输入和标准输出与命名文件关联起来。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ addItems &lt;infile&gt;outfile</div></pre></td></tr></table></figure></p><p>addItem 为编译后的可执行文件，上述命令会从一个名为 infile 的文件读取销售记录，并将输出结果写入一个名为 outfile 的文件中。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Sale_item.h"</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">Sale_item item1, item2;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;item1&gt;&gt;item2;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;item1+item2&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>可寻址的最小内存块称为 字节 (byte)，存储的基本单元称为 字 (word)，一个字节由八个比特（bit）构成，一个字由32或64比特构成。</p><ul><li><code>char</code> 8位（bits），一字节（bytes）</li><li><code>int</code> 32位，四字节</li><li><code>float</code> ，32位，6位有效数字</li><li><code>double</code> 64位，10位有效数字</li><li><code>char16_t</code> &amp; <code>char32_t</code> 为 Unicode 字符</li><li><code>short</code> 16bits</li><li><code>long</code> 32 bits</li><li><code>long long</code> 64 bits</li><li><code>long double</code> 96 or 128 bits</li><li><code>0</code>开头为八进制，<code>0x</code> 开头十六进制</li></ul><p>执行浮点数运算选用 double， 因为 float 通常精度不够，而且双精度浮点数和单精度浮点数的计算代价差不多。</p><p><strong>勿混用有符号类型与无符号类型</strong><br>如果 int 和无符号运算，那么 int 值会自动转变为无符号数。</p><p>当从无符号数中减去一个值时，不管这个数是不是无符号数，我们都必须确保结果不能是一个负值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> u1=<span class="number">42</span>,u2=<span class="number">10</span>;</div><div class="line"><span class="built_in">cout</span>&lt;&lt;u2-u1&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">输出：<span class="number">4294967264</span></div></pre></td></tr></table></figure><p>浮点数科学计数法表示：指数部分用 E 或 e 标识: <code>24E2</code>-><code>2400</code></p><p><strong>引用（reference）</strong>为对象起了另外一个名字，引用必须被初始化。通过将声明符写成<code>&amp;d</code>的形式来定义引用类型，其中<code>d</code>是声明的变量名。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。即定义了一个引用后，对其进行的所有操作都是在与之绑定的对象上进行的。</p><p><strong>空指针</strong>不指向任何对象，在试图使用一个指针之前代码可以先检测它是否为空。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *p1=<span class="literal">nullptr</span>;<span class="comment">// &lt;--- best</span></div><div class="line"><span class="keyword">int</span> *p2=<span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> *p3=<span class="literal">NULL</span>;<span class="comment">//#include &lt;cstdlib&gt;</span></div></pre></td></tr></table></figure></p><p>把 int 变量直接给指针是错误的，即使该值是0。</p><p><strong>指向指针的引用</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i=<span class="number">42</span>;</div><div class="line"><span class="keyword">int</span> *p;</div><div class="line"><span class="keyword">int</span> *&amp;r=p;<span class="comment">// r 是一个对指针 p 的引用</span></div><div class="line">r=&amp;i;<span class="comment">// p 指向 r</span></div><div class="line">*r=<span class="number">0</span>;</div></pre></td></tr></table></figure><p>从右向左阅读 r 的定义，首先是<code>&amp;</code>，说明 r 是一个引用，其次是<code>*</code>，表示 r 引用的是指针，最后<code>int</code>，r 引用的是 int 指针。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;之前学的不够扎实，更加系统、贴近底层的学一遍。非新手笔记，都是比较基础的东西，但没有最最基础的东西&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://zhstark.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://zhstark.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++函数的参数的不同传递方式</title>
    <link href="http://zhstark.com/2019/02/28/C-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E7%9A%84%E4%B8%8D%E5%90%8C%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F/"/>
    <id>http://zhstark.com/2019/02/28/C-函数的参数的不同传递方式/</id>
    <published>2019-02-28T14:52:28.000Z</published>
    <updated>2019-03-01T04:49:13.552Z</updated>
    
    <content type="html"><![CDATA[<p>面试要用 C++，没用 C++写过任何 project， 从头开始学 妈耶可烦死我了。</p><p>刷题时看到关于 C++函数的参数传递有好多形式，有直接传的，有传指针的，还有传<code>&amp;</code>，最后一个没怎么见过。找了些资料，发现这些对应的是值传递，指针传递和引用传递。</p><a id="more"></a><p>在这个<a href="https://www.cnblogs.com/yanlingyin/archive/2011/12/07/2278961.html" target="_blank" rel="external">博客</a>找到了非常深入的解释，摘抄部分如下：</p><p>（注：函数中用于接收传递值的变量叫形参，传递给函数的值叫实参）</p><p><strong>值传递</strong>：</p><p>形参是实参的拷贝，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参-&gt;形参），参数的值只能传入，不能传出。当函数内部需要修改参数，并且不希望这个改变影响调用者时，采用值传递。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;n++;&#125;    <span class="comment">// 外面传来的 n 不变</span></div></pre></td></tr></table></figure></p><p><strong>指针传递</strong>：</p><p>形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> *n)</span></span>&#123;*n=*n+<span class="number">1</span>;&#125;  <span class="comment">//外面的 n 也变</span></div></pre></td></tr></table></figure></p><p><strong>引用传递</strong>：</p><p>形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">int</span> &amp;n)</span></span>&#123;n++;&#125;       <span class="comment">////外面的 n 也变</span></div><div class="line"></div><div class="line"><span class="comment">//对引用传递，传入的时候只是传 n，不同于指针传 &amp;n</span></div><div class="line"><span class="keyword">int</span> n=<span class="number">2</span>;</div><div class="line">f3(n);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面试要用 C++，没用 C++写过任何 project， 从头开始学 妈耶可烦死我了。&lt;/p&gt;
&lt;p&gt;刷题时看到关于 C++函数的参数传递有好多形式，有直接传的，有传指针的，还有传&lt;code&gt;&amp;amp;&lt;/code&gt;，最后一个没怎么见过。找了些资料，发现这些对应的是值传递，指针传递和引用传递。&lt;/p&gt;
    
    </summary>
    
      <category term="记录" scheme="http://zhstark.com/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="tech" scheme="http://zhstark.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>github page自定义域名的 ip 过时</title>
    <link href="http://zhstark.com/2019/02/16/github%20page%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E7%9A%84%20ip%20%E8%BF%87%E6%97%B6/"/>
    <id>http://zhstark.com/2019/02/16/github page自定义域名的 ip 过时/</id>
    <published>2019-02-16T09:26:29.000Z</published>
    <updated>2019-02-16T22:01:02.949Z</updated>
    
    <content type="html"><![CDATA[<p>今天改博客的时候，每次部署都会收到 github 的邮件说：</p><p>The custom domain for your GitHub Pages site is pointed at an outdated IP address. You must update your site’s DNS records if you’d like it to be available via your custom domain.</p><a id="more"></a><p>因为现在 github page 现在的ip换了，之前自己的域名绑定的ip 不再试用。</p><p>解决之道：</p><p>登录自己的域名管理网站（我的是托管到 DNSPOD 上的），将之前的 ip 为192.30.252.153的关掉，添加 185.199.108.153<br><img src="/images/Screen Shot 2019-02-16 at 4.57.44 PM.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天改博客的时候，每次部署都会收到 github 的邮件说：&lt;/p&gt;
&lt;p&gt;The custom domain for your GitHub Pages site is pointed at an outdated IP address. You must update your site’s DNS records if you’d like it to be available via your custom domain.&lt;/p&gt;
    
    </summary>
    
      <category term="记录" scheme="http://zhstark.com/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="tech" scheme="http://zhstark.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>python学习笔记2</title>
    <link href="http://zhstark.com/2019/02/16/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
    <id>http://zhstark.com/2019/02/16/python学习笔记2/</id>
    <published>2019-02-16T08:43:00.000Z</published>
    <updated>2019-02-16T22:01:21.879Z</updated>
    
    <content type="html"><![CDATA[<p>接上部</p><a id="more"></a><h2 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h2><p><img src="/images/Screen Shot 2018-11-12 at 7.21.06 PM.png" alt=""></p><h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><h4 id="eval"><a href="#eval" class="headerlink" title="eval( )"></a>eval( )</h4><p>eval() 函数用来执行一个字符串表达式，并返回表达式的值。</p><h4 id="range-倒序"><a href="#range-倒序" class="headerlink" title="range( ) 倒序"></a>range( ) 倒序</h4><p><code>range(a,b,-1)</code></p><h4 id="enumerate-函数"><a href="#enumerate-函数" class="headerlink" title="enumerate( ) 函数"></a>enumerate( ) 函数</h4><p><code>enumerate()</code> 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;seasons = [<span class="string">'Spring'</span>, <span class="string">'Summer'</span>, <span class="string">'Fall'</span>, <span class="string">'Winter'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(enumerate(seasons))</div><div class="line">[(<span class="number">0</span>, <span class="string">'Spring'</span>), (<span class="number">1</span>, <span class="string">'Summer'</span>), (<span class="number">2</span>, <span class="string">'Fall'</span>), (<span class="number">3</span>, <span class="string">'Winter'</span>)]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(enumerate(seasons, start=<span class="number">1</span>))       <span class="comment"># 下标从 1 开始</span></div><div class="line">[(<span class="number">1</span>, <span class="string">'Spring'</span>), (<span class="number">2</span>, <span class="string">'Summer'</span>), (<span class="number">3</span>, <span class="string">'Fall'</span>), (<span class="number">4</span>, <span class="string">'Winter'</span>)]</div><div class="line"></div><div class="line">&gt;&gt;&gt;seq = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, element <span class="keyword">in</span> enumerate(seq):</div><div class="line"><span class="meta">... </span>    <span class="keyword">print</span> i, element</div><div class="line">...</div><div class="line"><span class="number">0</span> one</div><div class="line"><span class="number">1</span> two</div><div class="line"><span class="number">2</span> three</div></pre></td></tr></table></figure><h4 id="filter-函数"><a href="#filter-函数" class="headerlink" title="filter( ) 函数"></a>filter( ) 函数</h4><p>filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回一个迭代器对象，如果要转换为列表，可以使用 <code>list()</code> 来转换。</p><p>该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python3</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_odd</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">1</span></div><div class="line"></div><div class="line">tmplist = filter(is_odd, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>])</div><div class="line">newlist = list(tmplist)</div><div class="line">print(newlist)</div><div class="line"></div><div class="line">&gt;&gt;&gt;[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</div></pre></td></tr></table></figure><h4 id="zip-函数"><a href="#zip-函数" class="headerlink" title="zip( ) 函数"></a>zip( ) 函数</h4><p><code>zip()</code> 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象，这样做的好处是节约了不少的内存。<br><code>return min((b-a) for a, b in zip(m, m[1:]))</code></p><h4 id="divmod-函数"><a href="#divmod-函数" class="headerlink" title="divmod( )函数"></a>divmod( )函数</h4><p>python divmod() 函数把除数和余数运算结果结合起来，返回一个包含商和余数的元组(a // b, a % b)。</p><h4 id="join-函数"><a href="#join-函数" class="headerlink" title="join( ) 函数"></a>join( ) 函数</h4><p><code>‘s’.join(str)</code><br>s: 分隔符，可以为空<br>str：要连接的元素序列、字符串、元组、字典<br>上面的语法即：以sep作为分隔符，将seq所有的元素合并成一个新的字符串</p><p>返回值：返回一个以分隔符sep连接各个元素后生成的字符串</p><h4 id="contains"><a href="#contains" class="headerlink" title="__contains__"></a>__contains__</h4><p>在类中定义，在外面当用到 for i in class 时，<code>in</code> 调用该函数<br><code>in = contains()</code><br><code>x.__contain__(y)&lt;==&gt; y in x</code></p><h2 id="Import"><a href="#Import" class="headerlink" title="Import"></a>Import</h2><h4 id="collections-Counter"><a href="#collections-Counter" class="headerlink" title="collections.Counter"></a>collections.Counter</h4><p>Counter类的目的是用来跟踪值出现的次数。它是一个无序的容器类型，以字典的键值对形式存储，其中元素作为key，其计数作为value。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>c = Counter()  <span class="comment"># 创建一个空的Counter类</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c = Counter(<span class="string">'gallahad'</span>)  <span class="comment"># 从一个可iterable对象（list、tuple、dict、字符串等）创建</span></div></pre></td></tr></table></figure><h4 id="collections-deque"><a href="#collections-deque" class="headerlink" title="collections.deque"></a>collections.deque</h4><p>deque 是双边队列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">d = collections.deque([])</div><div class="line">d.append(<span class="string">'a'</span>) <span class="comment"># 在最右边添加一个元素，此时 d=deque('a')</span></div><div class="line">d.appendleft(<span class="string">'b'</span>) <span class="comment"># 在最左边添加一个元素，此时 d=deque(['b', 'a'])</span></div><div class="line">d.extend([<span class="string">'c'</span>,<span class="string">'d'</span>]) <span class="comment"># 在最右边添加所有元素，此时 d=deque(['b', 'a', 'c', 'd'])</span></div><div class="line">d.extendleft([<span class="string">'e'</span>,<span class="string">'f'</span>]) <span class="comment"># 在最左边添加所有元素，此时 d=deque(['f', 'e', 'b', 'a', 'c', 'd'])</span></div><div class="line">d.pop() <span class="comment"># 将最右边的元素取出，返回 'd'，此时 d=deque(['f', 'e', 'b', 'a', 'c'])</span></div><div class="line">d.popleft() <span class="comment"># 将最左边的元素取出，返回 'f'，此时 d=deque(['e', 'b', 'a', 'c'])</span></div><div class="line">d.rotate(<span class="number">-2</span>) <span class="comment"># 向左旋转两个位置（正数则向右旋转），此时 d=deque(['a', 'c', 'e', 'b'])</span></div><div class="line">d.count(<span class="string">'a'</span>) <span class="comment"># 队列中'a'的个数，返回 1</span></div><div class="line">d.remove(<span class="string">'c'</span>) <span class="comment"># 从队列中将'c'删除，此时 d=deque(['a', 'e', 'b'])</span></div><div class="line">d.reverse() <span class="comment"># 将队列倒序，此时 d=deque(['b', 'e', 'a'])</span></div></pre></td></tr></table></figure><h4 id="collections-defaultdict"><a href="#collections-defaultdict" class="headerlink" title="collections.defaultdict( )"></a>collections.defaultdict( )</h4><p>免去查看字典里是否有 key 的操作，如果没有直接加上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 普通 dictionary</span></div><div class="line">graph=&#123;&#125;</div><div class="line"><span class="keyword">for</span> u, v, w <span class="keyword">in</span> times:</div><div class="line">    <span class="keyword">if</span> u <span class="keyword">not</span> <span class="keyword">in</span> graph:</div><div class="line">        graph[u]=[(v, w)]</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        graph[u].append((v, w))</div><div class="line"></div><div class="line"><span class="comment"># 骚操作</span></div><div class="line">graph=collections.defaultdict(list)</div><div class="line"><span class="keyword">for</span> u, v, w <span class="keyword">in</span> times:</div><div class="line">    graph[u].append((v,w))</div></pre></td></tr></table></figure><h4 id="heapq"><a href="#heapq" class="headerlink" title="heapq"></a>heapq</h4><p>最小堆（优先队列）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>l=[<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>heapq.heapify(l)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>l</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>]</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>h=[]                    <span class="comment">#定义一个list</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> heapq    <span class="comment">#引入heapq模块</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>h</div><div class="line">[]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>heappush(h,<span class="number">5</span>)               <span class="comment">#向堆中依次增加数值</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>heappush(h,<span class="number">2</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>heappush(h,<span class="number">3</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>heappush(h,<span class="number">9</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>h                           <span class="comment">#h的值</span></div><div class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>heappop(h)                  <span class="comment">#从h中删除最小的，并返回该值</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>h</div><div class="line">[<span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>h.append(<span class="number">1</span>)                 <span class="comment">#注意，如果不是压入堆中，而是通过append追加一个数值</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>h                           <span class="comment">#堆的函数并不能操作这个增加的数值，或者说它堆对来讲是不存在的</span></div><div class="line">[<span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">1</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>heappop(h)                  <span class="comment">#从h中能够找到的最小值是3,而不是1</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>heappush(h,<span class="number">2</span>)               <span class="comment">#这时，不仅将2压入到堆内，而且1也进入了堆。</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>h</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">5</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>heappop(h)                  <span class="comment">#操作对象已经包含了1</span></div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure></p><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><p> <code>f=abs</code> 函数本身可以赋值给变量，即变量可以指向函数。<br>既然变量可以指向函数，函数的参数能接受变量，那么一个函数就可以接受另一个函数作为参数，这种函数就称之为高级函数</p><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p><code>map()</code> 函数接受两个参数，一个是函数，一个是<code>Iterable</code>，<code>map</code>将传入的函数依次作用到序列的每个元素，，并把结果作为新的<code>Iterator</code>返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> x * x</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = map(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(r)</div><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(str, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]))</div><div class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>]</div></pre></td></tr></table></figure><blockquote><p>感觉这个跟 <code>filter( ）</code> 有点像啊，<code>filter( )</code>接受一个是函数，一个是 list，返回一个迭代器，将返回 True 的放进去。</p></blockquote><h4 id="reduce-函数"><a href="#reduce-函数" class="headerlink" title="reduce 函数"></a>reduce 函数</h4><p><code>reduce( )</code>把一个函数作用在一个序列上，这个函数必须接受两个参数，<code>reduce</code>吧结果继续和序列的下一个函数做累积计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> x + y</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(add, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])</div><div class="line"><span class="number">25</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(x, y)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> x * <span class="number">10</span> + y</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(fn, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])</div><div class="line"><span class="number">13579</span></div></pre></td></tr></table></figure><h4 id="sorted-函数"><a href="#sorted-函数" class="headerlink" title="sorted( ) 函数"></a>sorted( ) 函数</h4><p>他可以接受一个<code>key</code>函数来实现自定义排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="number">36</span>, <span class="number">5</span>, <span class="number">-12</span>, <span class="number">9</span>, <span class="number">-21</span>], key=abs)</div><div class="line">[<span class="number">5</span>, <span class="number">9</span>, <span class="number">-12</span>, <span class="number">-21</span>, <span class="number">36</span>]</div></pre></td></tr></table></figure><p>还可反向排序，传入第三个参数： <code>reverse=True</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="string">'bob'</span>, <span class="string">'about'</span>, <span class="string">'Zoo'</span>, <span class="string">'Credit'</span>], key=str.lower, reverse=<span class="keyword">True</span>)</div><div class="line">[<span class="string">'Zoo'</span>, <span class="string">'Credit'</span>, <span class="string">'bob'</span>, <span class="string">'about'</span>]</div></pre></td></tr></table></figure><h2 id="匿名函数-lambda-x-x-x"><a href="#匿名函数-lambda-x-x-x" class="headerlink" title="匿名函数 lambda x: x+x"></a>匿名函数 lambda x: x+x</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接上部&lt;/p&gt;
    
    </summary>
    
      <category term="记录" scheme="http://zhstark.com/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="tech" scheme="http://zhstark.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>python学习笔记1</title>
    <link href="http://zhstark.com/2019/02/08/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <id>http://zhstark.com/2019/02/08/python学习笔记1/</id>
    <published>2019-02-08T08:31:21.000Z</published>
    <updated>2019-03-01T05:14:07.935Z</updated>
    
    <content type="html"><![CDATA[<p>如果要让 Python 打印出指定的文字，可以用print( )，把打印的文字用单引号或双引号括起来。</p><p>input( )函数输入，input 返回的数据类型是 str</p><p>#  开头的是注释</p><a id="more"></a><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>整数</li><li>浮点数</li><li>正负无穷<br>  <code>float(&quot;inf&quot;) and float(&quot;-inf&quot;)</code></li><li><p>字符串<br>  字符串是以单引号<em>‘</em>或双引号<em>“</em>括起来的文本。<br>  还可以用<code>r&#39; &#39;</code>表示<code>&#39; &#39;</code>内部不转义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">print(r&apos;\\\t\\\&apos;)</div><div class="line">&gt;&gt;&gt; \\\t\\\</div></pre></td></tr></table></figure></li><li><p>[] list；( ) tuple；<br>  <em>方法：append( ), pop( ), insert( a, b)</em>  </p></li><li><p>{ }dictionary<br> <code>dic[’a’]=b</code> <code>dic.pop(&#39;a&#39;)</code></p></li><li>set: key 的集合  但不存储value。<br>  创建一个 set 需要提供一个 list 作为输入集合。<br>  方法：add(key), remove(key),<br>  set 可以看成数学意义上的无序和无重复元素的集合</li><li>list 方法<br>  <code>l.count(1)</code> 值为1的有几个<br>  <code>b=a[:]</code> make a copy!<br>  <img src="/images/Image 2018-11-4 下午3-37.jpeg" alt=""></li><li>string 方法<br><img src="/images/Image 2018-11-4 下午3-39.jpeg" alt=""></li><li>set 方法<br><img src="/images/test1.jpeg" alt="test3"></li><li>dictionary 方法<br>  <code>dic.pop(key)</code><br>  <img src="/images/Image 2018-11-4 下午3-42.jpeg" alt=""></li></ul><h2 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">str=<span class="string">"www.zhstark.com"</span></div><div class="line">print(str.upper() )<span class="comment"># 把所有字符中的小写字母转换成大写字母</span></div><div class="line">print(str.lower() ) <span class="comment"># 把所有字符中的大写字母转换成小写字母</span></div><div class="line">print(str.capitalize() )  <span class="comment"># 把第一个字母转化为大写字母，其余小写</span></div><div class="line">print(str.title() ) <span class="comment"># 把每个单词的第一个字母转化为大写，其余小写</span></div><div class="line"></div><div class="line">WWW.RUNOOB.COM</div><div class="line">www.runoob.com</div><div class="line">Www.runoob.com</div><div class="line">Www.Runoob.Com</div></pre></td></tr></table></figure><h2 id="判断是否是数字或字母"><a href="#判断是否是数字或字母" class="headerlink" title="判断是否是数字或字母"></a>判断是否是数字或字母</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">str 是字符串</div><div class="line">str.isalnum() <span class="comment">#所有字符都是数字或者字母</span></div><div class="line">str.isalpha() <span class="comment">#所有字符都字母</span></div><div class="line">str.isdigit() <span class="comment">#所有字符都是数字</span></div><div class="line">str.islower() <span class="comment">#所有字符都是小写</span></div><div class="line">str.isupper()</div><div class="line">str.istitle() <span class="comment">#所有单词都是首字母大写</span></div><div class="line">str.isspace() <span class="comment">#所有字符都是空白字符、\t、\n、\r</span></div></pre></td></tr></table></figure><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; 'hello, %s' % 'world</div><div class="line">'hello, world'</div><div class="line">&gt;&gt;&gt; 'Hi, %s, you have $%d.' % ('Micheal', 99999)</div><div class="line"></div><div class="line">%d   整数</div><div class="line">%f 浮点数</div><div class="line">%s 字符串</div><div class="line">%x 十六进制整数</div></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>定义一个函数要使用的饭语句，依次写出函数名，括号，参数和冒号：</p><p>定义一个什么也不做的空函数，可以用 pass 语句：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">nop</span><span class="params">()</span>:</span></div><div class="line"><span class="keyword">pass</span></div></pre></td></tr></table></figure></p><p>pass可以用来做占位符</p><ul><li>位置参数<br>  <code>def power(x):</code></li><li>默认参数<br>  <code>def power(x, n=2):</code></li><li>可变参数<br>  <code>def calc(*number):</code><br>  参数 number 接收到的是一个 tuple</li><li>关键字参数<br>  <code>def person(name, age, **kw):</code></li><li>命名关键字参数<br>  <code>def person(name, age, *, city, job):</code><br>  <code>def person(name, age, *args, city, job):</code><br>  命名关键字参数必须传入参数名。</li></ul><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">L[<span class="number">0</span>:<span class="number">3</span>]</div><div class="line">L[:<span class="number">3</span>]</div><div class="line">L[<span class="number">-2</span>:]</div></pre></td></tr></table></figure><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>我们可以通过 for 循环来遍历一个 list或 tuple，这种遍历我们称为迭代 ( Iteration )<br>内置的 enumerate 函数可以把一个 list 变成索引-元素对  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i, value <span class="keyword">in</span> enumerate([<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,]):</div><div class="line">print(i, value)</div></pre></td></tr></table></figure><h4 id="列表生成器"><a href="#列表生成器" class="headerlink" title="列表生成器"></a>列表生成器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[k*k <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">11</span>)]</div></pre></td></tr></table></figure><h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>一边循环一边计算的机制，称为生成器：generator。<br>可以通过<code>next()</code>函数获得 generator 的下一个返回值。</p><ul><li><p>第一种方法，把列表生成式的[] 改成()，就创建了一个 generator<br>  <code>g=(x*x for x in range(10)）</code>  </p></li><li><p>第二种方法，如果一个函数定义中包含<em>yield</em>关键字，那么这个函数就不再是普通函数，而是一个 generator。  </p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(max)</span>:</span>  </div><div class="line">n,a,b=<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>  </div><div class="line"><span class="keyword">while</span> n&lt;max:  </div><div class="line"><span class="keyword">yield</span> b  </div><div class="line">a,b=b, a+b  </div><div class="line">n=n+<span class="number">1</span>  </div><div class="line"><span class="keyword">return</span> <span class="string">'done'</span></div></pre></td></tr></table></figure></li></ul><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>可以被 next()  函数调用并不断返回下一个值得对象成为迭代器： Iterator。<br>把 list, dict, str 等 Iterable 变成 Iterator 可以使用 iter() 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(iter(<span class="string">'abc'</span>), Iterator）</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果要让 Python 打印出指定的文字，可以用print( )，把打印的文字用单引号或双引号括起来。&lt;/p&gt;
&lt;p&gt;input( )函数输入，input 返回的数据类型是 str&lt;/p&gt;
&lt;p&gt;#  开头的是注释&lt;/p&gt;
    
    </summary>
    
      <category term="记录" scheme="http://zhstark.com/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="tech" scheme="http://zhstark.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>七牛图床链接失效</title>
    <link href="http://zhstark.com/2018/12/19/%E4%B8%83%E7%89%9B%E5%9B%BE%E5%BA%8A%E9%93%BE%E6%8E%A5%E5%A4%B1%E6%95%88/"/>
    <id>http://zhstark.com/2018/12/19/七牛图床链接失效/</id>
    <published>2018-12-18T16:14:05.000Z</published>
    <updated>2018-12-19T05:39:51.817Z</updated>
    
    <content type="html"><![CDATA[<p>突然发现以前博客的图片都没有了，查了一下是因为七牛的连接更改问题（我之前用的都是七牛的图床）。</p><a id="more"></a><p>找了个弥补方法的<a href="https://blog.csdn.net/lkj345/article/details/83382636" target="_blank" rel="external">链接</a>。懒得吧图片折腾回来了，反正也没人看=。=</p><p>在七牛新建一个存储空间还能继续用，希望七牛不要出这种幺蛾子了吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;突然发现以前博客的图片都没有了，查了一下是因为七牛的连接更改问题（我之前用的都是七牛的图床）。&lt;/p&gt;
    
    </summary>
    
      <category term="记录" scheme="http://zhstark.com/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>git push 重新输入密码</title>
    <link href="http://zhstark.com/2018/12/16/git%20push%20%E9%87%8D%E6%96%B0%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81/"/>
    <id>http://zhstark.com/2018/12/16/git push 重新输入密码/</id>
    <published>2018-12-16T15:42:01.000Z</published>
    <updated>2019-02-08T21:31:56.062Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一种情况"><a href="#第一种情况" class="headerlink" title="第一种情况"></a>第一种情况</h3><p>通过 <code>https://</code> clone 下来的，输入：<code>git config --global credential.helper store</code></p><p>网上普遍推这种方案，但我没试过</p><p>这种方案的缺点在于账户密码完全明文存储在本地，不安全。</p><h3 id="第二种情况"><a href="#第二种情况" class="headerlink" title="第二种情况"></a>第二种情况</h3><p>通过<code>SSH</code> clone 下来的，但每次 git push 仍要输入密码。<br><a id="more"></a></p><p>首先检查根目录下有没有 <code>.ssh</code> 文件</p><ul><li><p>如果有，运行</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-add -K ~/.ssh/id_rsa</div></pre></td></tr></table></figure></li><li><p>没有，</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -C "email@mail.com"</div><div class="line"></div><div class="line">git config --global user.name "name"</div><div class="line"></div><div class="line">git config --global user.email "email@mail.com"</div><div class="line"></div><div class="line">#测试</div><div class="line">ssh -T git@github.com</div></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;第一种情况&quot;&gt;&lt;a href=&quot;#第一种情况&quot; class=&quot;headerlink&quot; title=&quot;第一种情况&quot;&gt;&lt;/a&gt;第一种情况&lt;/h3&gt;&lt;p&gt;通过 &lt;code&gt;https://&lt;/code&gt; clone 下来的，输入：&lt;code&gt;git config --global credential.helper store&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;网上普遍推这种方案，但我没试过&lt;/p&gt;
&lt;p&gt;这种方案的缺点在于账户密码完全明文存储在本地，不安全。&lt;/p&gt;
&lt;h3 id=&quot;第二种情况&quot;&gt;&lt;a href=&quot;#第二种情况&quot; class=&quot;headerlink&quot; title=&quot;第二种情况&quot;&gt;&lt;/a&gt;第二种情况&lt;/h3&gt;&lt;p&gt;通过&lt;code&gt;SSH&lt;/code&gt; clone 下来的，但每次 git push 仍要输入密码。&lt;br&gt;
    
    </summary>
    
      <category term="记录" scheme="http://zhstark.com/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="tech" scheme="http://zhstark.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>添加路径到 PATH 的问题</title>
    <link href="http://zhstark.com/2018/10/17/%E6%B7%BB%E5%8A%A0%E8%B7%AF%E5%BE%84%E5%88%B0%20PATH%20%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://zhstark.com/2018/10/17/添加路径到 PATH 的问题/</id>
    <published>2018-10-17T15:08:27.000Z</published>
    <updated>2019-02-08T21:32:33.096Z</updated>
    
    <content type="html"><![CDATA[<p>该文章是记录我在捣鼓 pandoc 的时候出现 bug 并解决的过程。</p><a id="more"></a><p>由于我平时喜欢用 markdown 写作，如何编辑数学公式就成了难题。通过 pandoc，我可以在 markdown 里用 LaTeXiT 编辑公式，通过 pandoc 就可以导出显示公式的 pdf 了。但在我导出的时候，会有提示<code>pdflatex not found. pdflatex is needed for pdf output.</code>。我之前已经下载过 MacTex，所以<code>pdflatex</code>这东西我是一定安装好了，通过搜索，发现应该是路径没有导入 PATH 的问题。但是网上的教程对我来说并不管用，通过一系列折腾，终于搞清楚了问题所在。</p><p>当我们安装了新的底层程序（如 MacTex，npm），需要将其路径放到 PATH 中，在很多网络教程中，都是使用的该语句：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo nano /etc/paths</div></pre></td></tr></table></figure><p>将路径输入进文件，或者是：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> 'export <span class="built_in">PATH</span>="/usr/local/bin:$<span class="built_in">PATH</span>"' &gt;&gt; ~/.bash_profile</div></pre></td></tr></table></figure><p>然后用<code>echo $PATH</code> 查看，在某些情况下，该PATH 变量并没有任何改变，打开<code>/etc/paths</code> 文件，看到路径确实添加进去了。这是怎么回事呢？</p><p>这时候<code>echo $PATH</code> 所显示的路径其实属于 <code>bash_profile</code>，我们用文本编辑器打开该文件，看到里面有<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export <span class="built_in">PATH</span>="/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin"</div></pre></td></tr></table></figure></p><p>我们只需要将所要添加的路径续在<code>&quot; &quot;</code> 后面就可以了，记得用<code>:</code>与前面的路径分开。<br>eg：<br><code>export PATH=&quot;/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/Library/Tex/texbin&quot;</code><br>然后重启终端，再用<code>echo $PATH</code>，就发现已显示添加的路径。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;该文章是记录我在捣鼓 pandoc 的时候出现 bug 并解决的过程。&lt;/p&gt;
    
    </summary>
    
      <category term="记录" scheme="http://zhstark.com/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="tech" scheme="http://zhstark.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>中科院科研项目总结</title>
    <link href="http://zhstark.com/2016/10/08/%E4%B8%AD%E7%A7%91%E9%99%A2%E7%A7%91%E7%A0%94%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <id>http://zhstark.com/2016/10/08/中科院科研项目总结/</id>
    <published>2016-10-08T06:54:04.000Z</published>
    <updated>2016-10-08T06:54:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>前三部分为扯淡，第四部分描述了这个课题的过程步骤，第五部分为一些小感悟，第六部分是小福利。</em></p><hr><a id="more"></a><p><em>先扯扯淡</em></p><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>为期五天的科研营结束了，有收获，也有遗憾。</p><p>这五天确确实实学到了很多东西，不论是概念上的，还是方法、工具使用上的。终于大致理解了机器学习有哪些方法，基于的原理，并切实应用了 SVM 分类器。大二调了一年参数，本以为会了机器学习就可以让电脑自己搞出成果来，结果还是要自己再去调参数，真是蛋疼。</p><p>基于各种原因，最终我们并没有切实的完成这个课题，目前只是从一幅图片里提取出了车牌的区域，还不能让电脑认识车牌上的字符，写入文本。日后要补完，最好再整理重构一下。（一不小心就立了 flag = =）</p><p>短短五天，除了第一天，每天都是凌晨一点多才能睡。第二天9点上课，中午没有午休，却从没有像在学校一样听着课不小心就睡着。也许是老师讲课水平高，也许是这些知识确确实实吸引了我，激起了我的兴趣，总之，在这种强度下没有出现过上课睡着的情况甚至连打瞌睡都没有，对我来说，史无前例。</p><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>最后一天，走前在计算所里面简单逛了逛，发现其一楼布置的还是很赞的。内部有买咖啡的地方，应该是因为在假期吧，里面无人营业。</p><p><img src="http://obt165s4s.bkt.clouddn.com/IMG_1859.jpg" alt="IMG_1859"></p><p>咖啡店外面，提供了好长一排可以读书讨论的地方，沙发座椅，环境布置的很不错。</p><p><img src="http://obt165s4s.bkt.clouddn.com/IMG_1568.jpg" alt="IMG_1568"></p><p>我认为一个公司（/机构）里的厕所设置可以在很大程度上代表该公司（/机构）的硬件水平。不得不说计算所的厕所设置的还是很人性化的，至少在我所见过的建筑中，计算所的最贴心。内部采取的是人体红外感应，水龙头的距离感应特别靠谱，不像其他地方的要晃半天手才感应到。每个厕间都有放东西的小托盘，有厕纸。暖暖的，很贴心。</p><p>好久之后才发现，原来大名鼎鼎的搜狐就在旁边<br><img src="http://obt165s4s.bkt.clouddn.com/IMG_4511.jpg" alt="IMG_4511"></p><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>这次做东西最开心的莫过于终于不用 TMD 开虚拟机用 Windows了！不知要剩多少心，感觉自己又能多活五分钟。以后选专业就要选这种能全程使用 Mac，不像搞单片机那样离开 Windows 就 gg，Mac 给我的美感，舒适能让我坚持更长时间的工作( ⸝⸝⸝⁼̴́⌄⁼̴̀⸝⸝⸝)。工具嘛，必须用顺手的才有效率。</p><p>可惜的是没有带转接头，无法用自己电脑，展示PPT的时候只能讲Keynote 转为 pdf格式了。</p><h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><blockquote><p>以上都是扯淡<br>以下来稍微专业点的干货<br>有时候我会提出一些简单的问题，有兴趣的读者可以思考一下</p></blockquote><p>认识个车牌看似简单，但是要把这个检测识别做的足够强大，有更强的普适性，还是有很多工作要做的。单是对鱼眼镜头图像的校正处理就能发硕士毕业论文了。目前做的没那么复杂，只是对正视视角的车牌处理。但还是会分割为好多问题。</p><p>得到一幅图像，我们要通过一定的方法找到可能是车牌的区域，即选择符合一定规则的框框，作为车牌的“候选人”，下一步，便是在这些“候选人”中选择最合适的人选，即找出真正的带车牌的框框。该人选可能没有那么了解当前的业务，所以，下一步便是对选好的人选进行培训，即对所选的车牌区进行进一步优化处理，以便进一步识别出上面的字。最后，就是把一个字一个字都扣下来，进行模板匹配，从而将车牌上的字从“图像”的印象转为“字符”的印象。这是目前所差的步骤了，当然，在完成的过程中肯定还会遇到各种各样的问题，已经习惯麻木了<code>_(:3」∠)_</code></p><h3 id="4-1"><a href="#4-1" class="headerlink" title="4.1"></a>4.1</h3><p>读取图像就是从文件里找，当时老师要求做一个简单的 GUI 界面，我一脸懵逼的就去学做 GUI了，结果其实只需要一个内带的函数就可以自动跳出 GUI 界面让你选择文件。</p><h3 id="4-2"><a href="#4-2" class="headerlink" title="4.2"></a>4.2</h3><p>可能是车牌的区域怎么找嘞？方法很多，我们目前用了两种，第一种是通过颜色提取，因为车牌是蓝色的嘛（暂时只考虑蓝色车牌），那么只需要把蓝色的区域提取出来就是嫌疑牌喽。怎么提取呢？一张彩图是通过几个通道的数据合成出来的。比如 RGB 的图片格式，就是通过 R(red)<br>, G(green), B(blue)三个代表三种颜色的通道合成出来的。如果是 RGB 的图片格式的话，我们就可以选择 R G 通道数字小，B 通道在一定范围的区域作为嫌疑牌。不过目前我使用的是 Lab格式，测试过 hsv格式，效果不好。没有测试 RGB格式。找到嫌疑牌后，我们就把这张图片二值化，即把嫌疑牌说占的区域全部变成白色，其他变成黑色。（为什么要二值化呢？）</p><p><img src="http://obt165s4s.bkt.clouddn.com/proposal.png" alt="proposa"></p><p>第二种就是通过轮廓提取，对于一张灰度图来说，色差明显的地方我们可以视为边缘。这一步便是先利用 RGB 变灰度的经验公式对彩图进行灰度化，然后通过一定的算法对该灰度图提取边缘。（为什么不直接对彩图提取边缘呢？）提取后，凡是边缘的地方就是白色，不是边缘的就是黑色。因为车牌是白边蓝底白字，所以这种方法把车牌选中的难度不大。</p><p><img src="http://obt165s4s.bkt.clouddn.com/提取轮廓.png" alt="提取轮廓"></p><h3 id="4-3"><a href="#4-3" class="headerlink" title="4.3"></a>4.3</h3><p>现在我们得到了一张只有黑白两种颜色的图片，那，来回答为什么对通过颜色提取的图片进行二值化的问题。是为了和轮廓提取法相统一吗？通过轮廓提取就是二值化后的了。并非如此。二值化是为了方便我们的这一步处理。</p><p>因为只有黑白两种颜色，所以处理起来自然简单的多。所以这也是我们化简问题的一种方法。</p><p>对于得到的黑白图像，我们再对其做“腐蚀”或“膨胀”或既有“腐蚀”又有“膨胀”的处理（图像处理上的专业术语，放张图片感受下）。相当如对图片的一步润色。</p><p><img src="http://obt165s4s.bkt.clouddn.com/膨胀.jpg" alt="膨胀"></p><p><img src="http://obt165s4s.bkt.clouddn.com/腐蚀.jpg" alt="腐蚀"></p><p>不管是是通过轮廓还是颜色，对选的嫌疑牌的大小，形状都没有限定。所以有可能有很多小的零散的点，类似于噪声，总之那些一定是对我们没用的东西，所以我们再把那些特别小的点除去，这样，我们就得到了质量更高的嫌疑牌。（<em>类比于海选第二阶段，在淘汰掉一群倒霉孩子</em>）</p><h3 id="4-4"><a href="#4-4" class="headerlink" title="4.4"></a>4.4</h3><p>海选结束，我们得到了少数几个很有可能是车牌的区域，当然，我们需要的是他们的坐标信息。从而在原图像中把这些区域扣出来。</p><p>下一步，就是把真正的车牌选出来，这一步也是这个课题最有趣的部分。它需要用到机器学习的方法，让机器学着认识车牌。</p><p>机器毕竟不是人，它算的再快也没用像人类一样的抽象思维，它只能处理数字信息。那么如何让电脑认识车牌就是一个大问题。</p><p>既然电脑认识数字信息，那么我们就从图片上提取出数字信息呗。这项课题中我们便是提取图片的 HOG（histogram of gradient）特征。记住了一个图像的 HOG特征之后，那电脑就认识这幅图像了。</p><p>但是，你认识了这副图，下一幅类似的不认识了也不行啊，不能只认识黑体的“1”转为斜体“<em>1</em>”就一脸懵逼呀。</p><p>这时候，就要用到强大的 SVM分类器了。这一块之前的文章有过介绍，有兴趣的也可以网上查找资料，不再赘述罢。一句话：「把”是车牌”的 HOG特征和”不是车牌”的 HOG特征输入电脑，电脑以后就知道”啥样的是车牌，啥样的不是车牌”了。」</p><p>这样一来，我们把之前选好的嫌疑牌送给电脑，电脑就认得这些嫌疑牌中的真车牌了。</p><h3 id="4-5"><a href="#4-5" class="headerlink" title="4.5"></a>4.5</h3><p>这时候我们得到了的带车牌的区域，而我们最终的目的是要识别出上面的字。所以我们还有对这块区域进行进一步处理，方便我们更容易认识上面的字。</p><p>如果这时候的车牌是有小倾角的，我们对其进行 radon变换，将其摆正。然后再对其进行削边，凡是不包括字符的区域全部丢掉，丢掉！</p><p><img src="http://obt165s4s.bkt.clouddn.com/提取车牌信息.jpg" alt="提取车牌信息"></p><p>终于，我们得到了包含字符的最小区域。也是我目前做到的阶段。再下一步，就是认出上面的字了。</p><h3 id="4-6"><a href="#4-6" class="headerlink" title="4.6"></a>4.6</h3><p>电脑不够机灵，多个字放一起它认不得，得把单个的字分离出来，然后对每个字进行模板匹配，从而达到认识字的目的。这一部分等我完成再写，没有实际操作，纸上谈兵不靠谱。</p><h2 id="五"><a href="#五" class="headerlink" title="五"></a>五</h2><p>做这个项目有哪些感悟呢？</p><p>第一个是「维度」的概念，在 SVM 分类器中，对一个较复杂的情形做线性分割的方法便是「升维」。升到更高的维度后观察，非线性关系就转变为了线性关系，很多问题就可以轻易地解决了。就像我们身处三维空间就能很容易的解决二维平面的问题，而对三维空间中的物体处理起来却有时候力不从心，对四维空间中的东西……等等，什么四维空间？</p><p>第二个是「换位思考」，「换位思考」不仅仅是指与人换位，还可以与机器换位。在这个项目便是试着按照计算机的处理特点去思考。计算机没有感性思维，他只能处理数字信息，那如何才能让计算机像人类一样呢？我们就试着把我们说看到的东西转换为数字信息，一张张图片不就是一个个二维或三维的数组嘛，我们看到的什么颜色又对应数组中怎样的数值？试着从计算机的视角去看待事物，找到计算机与人相连接的桥梁，我们就知道如何让计算机像人一样看待事物了。</p><p>第三个是「搜索引擎是亲爹」。这个项目没有规定教材，不会的知识全靠网上搜，Google 百度用起来。我们处于「学习」阶段，不同于「研究」，我们遇到的问题之前都有还多人遇到过，我们走的路之前很多人也走过，所以，在这个阶段，互联网上有大量的资源可以帮助我们解决问题，搜一下就能找到，方便快捷。所以，<strong>检索能力很重要</strong>。</p><p><img src="http://obt165s4s.bkt.clouddn.com/Google first.jpg" alt="Google first"></p><p>第四，「数学就是亲爷爷」。</p><h2 id="六"><a href="#六" class="headerlink" title="六"></a>六</h2><p>这个项目我一定会完成，但是时间不好说，两周一个月都有可能。如果你对此有兴趣，可以回复“「车牌识别」+（你的邮箱）”，当我完成的时候会把全部代码上传到 github，并发邮件通知你 :）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;前三部分为扯淡，第四部分描述了这个课题的过程步骤，第五部分为一些小感悟，第六部分是小福利。&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Proactive" scheme="http://zhstark.com/categories/Proactive/"/>
    
    
  </entry>
  
  <entry>
    <title>中科院科研项目第三天</title>
    <link href="http://zhstark.com/2016/10/03/%E4%B8%AD%E7%A7%91%E9%99%A2%E7%A7%91%E7%A0%94%E9%A1%B9%E7%9B%AE%E7%AC%AC%E4%B8%89%E5%A4%A9/"/>
    <id>http://zhstark.com/2016/10/03/中科院科研项目第三天/</id>
    <published>2016-10-03T05:53:21.000Z</published>
    <updated>2016-10-21T12:29:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>今天晚上终于找到一家合适的咖啡店上自习，有网，安静。中科院不提供自习处，十一假期好多店又关门，每天晚上我们都是无家可归的状态，到处找地方蹭网做作业。而且，这家店老板的闺女挺漂亮哒，态度好，声音也好听，嘤嘤嘤。</p><a id="more"></a><p>项目一共五天，今天已经是第三天了，还有两天结束，周围开门的饭店已经被我吃遍了。。。。感觉每逢短期假期就是我遭罪的时候，不回家，然而在外面各个服务业又停业，没地方吃，没地方去，只有床才是最温暖的陪伴。</p><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>今天的作业是利用 HOG 提取体特征，将训练集送入 SVM 分类器让其学习，产生一个模型，再利用学习后的模型对我们需要分类的样本进行分类。</p><p>HOG 我还没太仔细看，解释不清楚，至于 SVM，可以看我上一篇文章最后的 gif 录屏，不要嫌那个动的太快，腾讯只让发2M 以下的 gif，我也没办法。其实只要我们上下摆头的速率和那张动图变化的速率一样，就能看清了。不难，我试了7次就合上拍了，还挺清晰的。</p><p>就我们目前做的课题来说，就是送一堆车牌的图片给电脑，并告诉他「看清楚了，这是车牌！」再送给他一坨不是车牌，但他可能以为是车牌的图片，告诉他「长点即兴，要是认错了发你跪键盘！」然后电脑就赶紧认认真真地去学习车牌长什么样子，不长什么样子。</p><p>等他学会后，吸收，消化，排泄，拉出一个模型便便💩，不屑地告诉我「我这便便能认识车牌了，你把这便便扣在有车牌的图片上，它把车牌给你熏下来。」</p><p>我如珍似宝地双手托着这宝贵的便便，使劲扣在一张图片上，它还真把车牌给熏下来了。我熏了一张又一张，发现，这便便味道不够足嘛，有的车牌还是熏不下来，唉。回去罚他跪键盘，但是发现作为一个穷逼，我并没有键盘让他跪。所以特此征好心人送我一个 cherry 键盘来让电脑跪，感激不尽。</p><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>其实让电脑学习还不是简单的给他资料他就能学。电脑，这个高贵的东西，肯定有点小脾气不是，所以你得对他性子才行，他喜欢吃苹果，你非得喂他吃榴莲，他肯定轻则罢学重则 down机啊，榴莲再贵也不行，不对电脑口味。</p><p>所以能，咱得找到电脑喜欢啥，给他点啥他才能更好的学习。电脑没长牙，那我就送他两个参数意思意思呗，他不告诉我他喜欢吃啥很是讨厌，我得一个个试，这电脑配置低，性格墨迹，试一次要好长时间，TMD，老子有钱了买个最高配，拿一筐苹果塞他嘴里，让他使劲吃，吃完使劲学。苹果不管用就塞梨，梨再不管用，那我只能破费请他吃个海底捞了。</p><p>目前我还没兴致找他口味，所以他现在拉出的便便质量也就那样吧，还凑活能用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一&quot;&gt;&lt;a href=&quot;#一&quot; class=&quot;headerlink&quot; title=&quot;一&quot;&gt;&lt;/a&gt;一&lt;/h2&gt;&lt;p&gt;今天晚上终于找到一家合适的咖啡店上自习，有网，安静。中科院不提供自习处，十一假期好多店又关门，每天晚上我们都是无家可归的状态，到处找地方蹭网做作业。而且，这家店老板的闺女挺漂亮哒，态度好，声音也好听，嘤嘤嘤。&lt;/p&gt;
    
    </summary>
    
      <category term="Proactive" scheme="http://zhstark.com/categories/Proactive/"/>
    
    
  </entry>
  
</feed>
